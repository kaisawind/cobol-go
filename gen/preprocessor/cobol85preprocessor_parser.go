// Code generated from preprocessor/Cobol85Preprocessor.g4 by ANTLR 4.13.0. DO NOT EDIT.

package preprocessor // Cobol85Preprocessor
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Cobol85PreprocessorParser struct {
	*antlr.BaseParser
}

var Cobol85PreprocessorParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cobol85preprocessorParserInit() {
	staticData := &Cobol85PreprocessorParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "'('", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "')'", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "'*>'", "','", "'.'", "'=='",
	}
	staticData.SymbolicNames = []string{
		"", "ADATA", "ADV", "ALIAS", "ANSI", "ANY", "APOST", "AR", "ARITH",
		"AUTO", "AWO", "BIN", "BLOCK0", "BUF", "BUFSIZE", "BY", "CBL", "CBLCARD",
		"CICS", "CO", "COBOL2", "COBOL3", "CODEPAGE", "COMPAT", "COMPILE", "COPY",
		"CP", "CPP", "CPSM", "CS", "CURR", "CURRENCY", "DATA", "DATEPROC", "DBCS",
		"DD", "DEBUG", "DECK", "DIAGTRUNC", "DLI", "DLL", "DP", "DTR", "DU",
		"DUMP", "DYN", "DYNAM", "EDF", "EJECT", "EJPD", "EN", "ENGLISH", "END_EXEC",
		"EPILOG", "EXCI", "EXEC", "EXIT", "EXP", "EXPORTALL", "EXTEND", "FASTSRT",
		"FEPI", "FLAG", "FLAGSTD", "FSRT", "FULL", "GDS", "GRAPHIC", "HOOK",
		"IN", "INTDATE", "JA", "JP", "KA", "LANG", "LANGUAGE", "LC", "LEASM",
		"LENGTH", "LIB", "LILIAN", "LIN", "LINECOUNT", "LINKAGE", "LIST", "LM",
		"LONGMIXED", "LONGUPPER", "LPARENCHAR", "LU", "MAP", "MARGINS", "MAX",
		"MD", "MDECK", "MIG", "MIXED", "NAME", "NAT", "NATIONAL", "NATLANG",
		"NN", "NO", "NOADATA", "NOADV", "NOALIAS", "NOAWO", "NOBLOCK0", "NOC",
		"NOCBLCARD", "NOCICS", "NOCMPR2", "NOCOMPILE", "NOCPSM", "NOCURR", "NOCURRENCY",
		"NOD", "NODATEPROC", "NODBCS", "NODE", "NODEBUG", "NODECK", "NODIAGTRUNC",
		"NODLL", "NODU", "NODUMP", "NODP", "NODTR", "NODYN", "NODYNAM", "NOEDF",
		"NOEJPD", "NOEPILOG", "NOEXIT", "NOEXP", "NOEXPORTALL", "NOF", "NOFASTSRT",
		"NOFEPI", "NOFLAG", "NOFLAGMIG", "NOFLAGSTD", "NOFSRT", "NOGRAPHIC",
		"NOHOOK", "NOLENGTH", "NOLIB", "NOLINKAGE", "NOLIST", "NOMAP", "NOMD",
		"NOMDECK", "NONAME", "NONUM", "NONUMBER", "NOOBJ", "NOOBJECT", "NOOFF",
		"NOOFFSET", "NOOPSEQUENCE", "NOOPT", "NOOPTIMIZE", "NOOPTIONS", "NOP",
		"NOPFD", "NOPROLOG", "NORENT", "NOS", "NOSEP", "NOSEPARATE", "NOSEQ",
		"NOSOURCE", "NOSPIE", "NOSQL", "NOSQLC", "NOSQLCCSID", "NOSSR", "NOSSRANGE",
		"NOSTDTRUNC", "NOSEQUENCE", "NOTERM", "NOTERMINAL", "NOTEST", "NOTHREAD",
		"NOTRIG", "NOVBREF", "NOWD", "NOWORD", "NOX", "NOXREF", "NOZWB", "NS",
		"NSEQ", "NSYMBOL", "NUM", "NUMBER", "NUMPROC", "OBJ", "OBJECT", "OF",
		"OFF", "OFFSET", "ON", "OP", "OPMARGINS", "OPSEQUENCE", "OPT", "OPTFILE",
		"OPTIMIZE", "OPTIONS", "OUT", "OUTDD", "PFD", "PPTDBG", "PGMN", "PGMNAME",
		"PREFIXING", "PROCESS", "PROLOG", "QUOTE", "RENT", "REPLACE", "REPLACING",
		"RMODE", "RPARENCHAR", "SEP", "SEPARATE", "SEQ", "SEQUENCE", "SHORT",
		"SIZE", "SOURCE", "SP", "SPACE", "SPIE", "SQL", "SQLC", "SQLCCSID",
		"SQLIMS", "SKIP1", "SKIP2", "SKIP3", "SS", "SSR", "SSRANGE", "STD",
		"SUPPRESS", "SYSEIB", "SZ", "TERM", "TERMINAL", "TEST", "THREAD", "TITLE",
		"TRIG", "TRUNC", "UE", "UPPER", "VBREF", "WD", "WORD", "XMLPARSE", "XMLSS",
		"XOPTS", "XP", "XREF", "YEARWINDOW", "YW", "ZWB", "C_CHAR", "D_CHAR",
		"E_CHAR", "F_CHAR", "H_CHAR", "I_CHAR", "M_CHAR", "N_CHAR", "Q_CHAR",
		"S_CHAR", "U_CHAR", "W_CHAR", "X_CHAR", "COMMENTTAG", "COMMACHAR", "DOT",
		"DOUBLEEQUALCHAR", "NONNUMERICLITERAL", "NUMERICLITERAL", "IDENTIFIER",
		"FILENAME", "PREFIX", "NEWLINE", "COMMENTLINE", "WS", "TEXT",
	}
	staticData.RuleNames = []string{
		"startRule", "compilerOptions", "compilerXOpts", "compilerOption", "execCicsStatement",
		"execSqlStatement", "execSqlImsStatement", "copyStatement", "copySource",
		"copyLibrary", "prefixingPhrase", "replacingPhrase", "replaceArea",
		"replaceByStatement", "replaceOffStatement", "replaceClause", "directoryPhrase",
		"familyPhrase", "replaceable", "replacement", "ejectStatement", "skipStatement",
		"titleStatement", "pseudoText", "charData", "charDataSql", "charDataLine",
		"cobolWord", "prefixWord", "literal", "filename", "charDataKeyword",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 294, 694, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
		0, 5, 0, 77, 8, 0, 10, 0, 12, 0, 80, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1,
		86, 8, 1, 1, 1, 1, 1, 4, 1, 90, 8, 1, 11, 1, 12, 1, 91, 1, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 98, 8, 2, 1, 2, 5, 2, 101, 8, 2, 10, 2, 12, 2, 104, 9, 2,
		1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 128,
		8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		3, 3, 153, 8, 3, 1, 3, 3, 3, 156, 8, 3, 1, 3, 3, 3, 159, 8, 3, 1, 3, 3,
		3, 162, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 182, 8, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 190, 8, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 3, 3, 222, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3,
		3, 230, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 236, 8, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		3, 3, 253, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 3, 3, 326, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 341, 8, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 363, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 373, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3,
		379, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 395, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 3, 3, 404, 8, 3, 1, 3, 3, 3, 407, 8, 3, 1, 3, 3, 3, 410, 8,
		3, 1, 3, 3, 3, 413, 8, 3, 1, 3, 3, 3, 416, 8, 3, 1, 3, 3, 3, 419, 8, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 439, 8, 3, 1, 3, 3, 3, 442, 8,
		3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 450, 8, 3, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 3, 4, 457, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 464,
		8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 471, 8, 6, 1, 7, 1, 7, 1, 7,
		5, 7, 476, 8, 7, 10, 7, 12, 7, 479, 9, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		3, 7, 486, 8, 7, 5, 7, 488, 8, 7, 10, 7, 12, 7, 491, 9, 7, 1, 7, 5, 7,
		494, 8, 7, 10, 7, 12, 7, 497, 9, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 3, 8,
		504, 8, 8, 1, 8, 1, 8, 3, 8, 508, 8, 8, 1, 9, 1, 9, 3, 9, 512, 8, 9, 1,
		10, 1, 10, 5, 10, 516, 8, 10, 10, 10, 12, 10, 519, 9, 10, 1, 10, 1, 10,
		1, 11, 1, 11, 5, 11, 525, 8, 11, 10, 11, 12, 11, 528, 9, 11, 1, 11, 1,
		11, 4, 11, 532, 8, 11, 11, 11, 12, 11, 533, 1, 11, 5, 11, 537, 8, 11, 10,
		11, 12, 11, 540, 9, 11, 1, 12, 1, 12, 1, 12, 5, 12, 545, 8, 12, 10, 12,
		12, 12, 548, 9, 12, 1, 12, 3, 12, 551, 8, 12, 1, 13, 1, 13, 5, 13, 555,
		8, 13, 10, 13, 12, 13, 558, 9, 13, 1, 13, 4, 13, 561, 8, 13, 11, 13, 12,
		13, 562, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 5, 15,
		573, 8, 15, 10, 15, 12, 15, 576, 9, 15, 1, 15, 1, 15, 5, 15, 580, 8, 15,
		10, 15, 12, 15, 583, 9, 15, 1, 15, 1, 15, 5, 15, 587, 8, 15, 10, 15, 12,
		15, 590, 9, 15, 1, 15, 3, 15, 593, 8, 15, 1, 15, 5, 15, 596, 8, 15, 10,
		15, 12, 15, 599, 9, 15, 1, 15, 3, 15, 602, 8, 15, 1, 16, 1, 16, 5, 16,
		606, 8, 16, 10, 16, 12, 16, 609, 9, 16, 1, 16, 1, 16, 3, 16, 613, 8, 16,
		1, 17, 1, 17, 5, 17, 617, 8, 17, 10, 17, 12, 17, 620, 9, 17, 1, 17, 1,
		17, 3, 17, 624, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 630, 8, 18, 1,
		19, 1, 19, 1, 19, 1, 19, 3, 19, 636, 8, 19, 1, 20, 1, 20, 3, 20, 640, 8,
		20, 1, 21, 1, 21, 3, 21, 644, 8, 21, 1, 22, 1, 22, 1, 22, 3, 22, 649, 8,
		22, 1, 23, 1, 23, 3, 23, 653, 8, 23, 1, 23, 1, 23, 1, 24, 1, 24, 4, 24,
		659, 8, 24, 11, 24, 12, 24, 660, 1, 25, 1, 25, 1, 25, 1, 25, 4, 25, 667,
		8, 25, 11, 25, 12, 25, 668, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1,
		26, 4, 26, 678, 8, 26, 11, 26, 12, 26, 679, 1, 27, 1, 27, 3, 27, 684, 8,
		27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 0, 0,
		32, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 0, 83, 2, 0, 16,
		16, 217, 217, 1, 0, 7, 8, 4, 0, 23, 23, 59, 59, 269, 269, 271, 271, 1,
		0, 13, 14, 2, 0, 22, 22, 26, 26, 2, 0, 24, 24, 269, 269, 1, 0, 30, 31,
		2, 0, 33, 33, 41, 41, 2, 0, 62, 62, 139, 139, 2, 0, 184, 184, 254, 254,
		2, 0, 37, 37, 270, 270, 2, 0, 38, 38, 42, 42, 1, 0, 43, 44, 1, 0, 45, 46,
		1, 0, 57, 58, 2, 0, 60, 60, 64, 64, 2, 0, 62, 62, 272, 272, 3, 0, 271,
		271, 274, 274, 278, 280, 1, 0, 273, 275, 6, 0, 35, 35, 101, 101, 242, 242,
		270, 270, 276, 276, 278, 278, 2, 0, 4, 4, 80, 80, 1, 0, 74, 75, 4, 0, 29,
		29, 50, 51, 71, 73, 256, 256, 2, 0, 76, 76, 82, 82, 1, 0, 93, 94, 4, 0,
		24, 24, 108, 108, 112, 112, 269, 269, 2, 0, 3, 3, 105, 105, 3, 0, 29, 29,
		50, 50, 73, 73, 2, 0, 108, 108, 112, 112, 3, 0, 271, 271, 278, 278, 280,
		280, 1, 0, 114, 115, 2, 0, 117, 117, 126, 126, 2, 0, 116, 116, 121, 121,
		1, 0, 124, 125, 2, 0, 122, 122, 127, 127, 1, 0, 128, 129, 1, 0, 134, 135,
		2, 0, 137, 137, 142, 142, 2, 0, 136, 136, 139, 139, 1, 0, 150, 151, 1,
		0, 153, 154, 1, 0, 155, 156, 1, 0, 157, 158, 1, 0, 160, 161, 2, 0, 170,
		170, 179, 179, 2, 0, 167, 167, 171, 171, 1, 0, 174, 175, 1, 0, 176, 177,
		1, 0, 180, 181, 1, 0, 186, 187, 2, 0, 191, 191, 193, 193, 2, 0, 34, 34,
		98, 99, 1, 0, 188, 189, 1, 0, 194, 195, 3, 0, 95, 95, 164, 164, 212, 212,
		1, 0, 197, 198, 1, 0, 200, 201, 2, 0, 206, 206, 208, 208, 2, 0, 65, 65,
		245, 245, 1, 0, 210, 211, 1, 0, 214, 215, 8, 0, 19, 19, 23, 23, 85, 87,
		89, 89, 96, 96, 257, 257, 275, 275, 279, 279, 2, 0, 219, 219, 277, 277,
		1, 0, 227, 228, 2, 0, 230, 230, 248, 248, 2, 0, 231, 231, 278, 278, 1,
		0, 236, 237, 1, 0, 243, 244, 1, 0, 249, 250, 2, 0, 68, 68, 144, 144, 2,
		0, 168, 169, 225, 226, 2, 0, 49, 49, 131, 131, 3, 0, 11, 11, 206, 206,
		245, 245, 1, 0, 259, 260, 2, 0, 261, 261, 264, 264, 4, 0, 23, 23, 262,
		262, 269, 269, 281, 281, 2, 0, 265, 265, 281, 281, 2, 0, 65, 65, 229, 229,
		1, 0, 266, 267, 2, 0, 69, 69, 199, 199, 1, 0, 239, 241, 1, 0, 286, 287,
		17, 0, 1, 17, 19, 24, 26, 51, 53, 54, 56, 60, 62, 76, 78, 87, 89, 185,
		187, 215, 217, 220, 222, 223, 225, 237, 242, 245, 247, 259, 261, 263, 265,
		281, 283, 283, 907, 0, 78, 1, 0, 0, 0, 2, 83, 1, 0, 0, 0, 4, 93, 1, 0,
		0, 0, 6, 449, 1, 0, 0, 0, 8, 451, 1, 0, 0, 0, 10, 458, 1, 0, 0, 0, 12,
		465, 1, 0, 0, 0, 14, 472, 1, 0, 0, 0, 16, 503, 1, 0, 0, 0, 18, 511, 1,
		0, 0, 0, 20, 513, 1, 0, 0, 0, 22, 522, 1, 0, 0, 0, 24, 541, 1, 0, 0, 0,
		26, 552, 1, 0, 0, 0, 28, 566, 1, 0, 0, 0, 30, 570, 1, 0, 0, 0, 32, 603,
		1, 0, 0, 0, 34, 614, 1, 0, 0, 0, 36, 629, 1, 0, 0, 0, 38, 635, 1, 0, 0,
		0, 40, 637, 1, 0, 0, 0, 42, 641, 1, 0, 0, 0, 44, 645, 1, 0, 0, 0, 46, 650,
		1, 0, 0, 0, 48, 658, 1, 0, 0, 0, 50, 666, 1, 0, 0, 0, 52, 677, 1, 0, 0,
		0, 54, 683, 1, 0, 0, 0, 56, 685, 1, 0, 0, 0, 58, 687, 1, 0, 0, 0, 60, 689,
		1, 0, 0, 0, 62, 691, 1, 0, 0, 0, 64, 77, 3, 2, 1, 0, 65, 77, 3, 14, 7,
		0, 66, 77, 3, 8, 4, 0, 67, 77, 3, 10, 5, 0, 68, 77, 3, 12, 6, 0, 69, 77,
		3, 28, 14, 0, 70, 77, 3, 24, 12, 0, 71, 77, 3, 40, 20, 0, 72, 77, 3, 42,
		21, 0, 73, 77, 3, 44, 22, 0, 74, 77, 3, 52, 26, 0, 75, 77, 5, 291, 0, 0,
		76, 64, 1, 0, 0, 0, 76, 65, 1, 0, 0, 0, 76, 66, 1, 0, 0, 0, 76, 67, 1,
		0, 0, 0, 76, 68, 1, 0, 0, 0, 76, 69, 1, 0, 0, 0, 76, 70, 1, 0, 0, 0, 76,
		71, 1, 0, 0, 0, 76, 72, 1, 0, 0, 0, 76, 73, 1, 0, 0, 0, 76, 74, 1, 0, 0,
		0, 76, 75, 1, 0, 0, 0, 77, 80, 1, 0, 0, 0, 78, 76, 1, 0, 0, 0, 78, 79,
		1, 0, 0, 0, 79, 81, 1, 0, 0, 0, 80, 78, 1, 0, 0, 0, 81, 82, 5, 0, 0, 1,
		82, 1, 1, 0, 0, 0, 83, 89, 7, 0, 0, 0, 84, 86, 5, 283, 0, 0, 85, 84, 1,
		0, 0, 0, 85, 86, 1, 0, 0, 0, 86, 87, 1, 0, 0, 0, 87, 90, 3, 6, 3, 0, 88,
		90, 3, 4, 2, 0, 89, 85, 1, 0, 0, 0, 89, 88, 1, 0, 0, 0, 90, 91, 1, 0, 0,
		0, 91, 89, 1, 0, 0, 0, 91, 92, 1, 0, 0, 0, 92, 3, 1, 0, 0, 0, 93, 94, 5,
		263, 0, 0, 94, 95, 5, 88, 0, 0, 95, 102, 3, 6, 3, 0, 96, 98, 5, 283, 0,
		0, 97, 96, 1, 0, 0, 0, 97, 98, 1, 0, 0, 0, 98, 99, 1, 0, 0, 0, 99, 101,
		3, 6, 3, 0, 100, 97, 1, 0, 0, 0, 101, 104, 1, 0, 0, 0, 102, 100, 1, 0,
		0, 0, 102, 103, 1, 0, 0, 0, 103, 105, 1, 0, 0, 0, 104, 102, 1, 0, 0, 0,
		105, 106, 5, 224, 0, 0, 106, 5, 1, 0, 0, 0, 107, 450, 5, 1, 0, 0, 108,
		450, 5, 2, 0, 0, 109, 450, 5, 6, 0, 0, 110, 111, 7, 1, 0, 0, 111, 112,
		5, 88, 0, 0, 112, 113, 7, 2, 0, 0, 113, 450, 5, 224, 0, 0, 114, 450, 5,
		10, 0, 0, 115, 450, 5, 12, 0, 0, 116, 117, 7, 3, 0, 0, 117, 118, 5, 88,
		0, 0, 118, 119, 3, 58, 29, 0, 119, 120, 5, 224, 0, 0, 120, 450, 1, 0, 0,
		0, 121, 450, 5, 17, 0, 0, 122, 127, 5, 18, 0, 0, 123, 124, 5, 88, 0, 0,
		124, 125, 3, 58, 29, 0, 125, 126, 5, 224, 0, 0, 126, 128, 1, 0, 0, 0, 127,
		123, 1, 0, 0, 0, 127, 128, 1, 0, 0, 0, 128, 450, 1, 0, 0, 0, 129, 450,
		5, 20, 0, 0, 130, 450, 5, 21, 0, 0, 131, 132, 7, 4, 0, 0, 132, 133, 5,
		88, 0, 0, 133, 134, 3, 58, 29, 0, 134, 135, 5, 224, 0, 0, 135, 450, 1,
		0, 0, 0, 136, 450, 7, 5, 0, 0, 137, 450, 5, 27, 0, 0, 138, 450, 5, 28,
		0, 0, 139, 140, 7, 6, 0, 0, 140, 141, 5, 88, 0, 0, 141, 142, 3, 58, 29,
		0, 142, 143, 5, 224, 0, 0, 143, 450, 1, 0, 0, 0, 144, 145, 5, 32, 0, 0,
		145, 146, 5, 88, 0, 0, 146, 147, 3, 58, 29, 0, 147, 148, 5, 224, 0, 0,
		148, 450, 1, 0, 0, 0, 149, 161, 7, 7, 0, 0, 150, 152, 5, 88, 0, 0, 151,
		153, 7, 8, 0, 0, 152, 151, 1, 0, 0, 0, 152, 153, 1, 0, 0, 0, 153, 155,
		1, 0, 0, 0, 154, 156, 5, 283, 0, 0, 155, 154, 1, 0, 0, 0, 155, 156, 1,
		0, 0, 0, 156, 158, 1, 0, 0, 0, 157, 159, 7, 9, 0, 0, 158, 157, 1, 0, 0,
		0, 158, 159, 1, 0, 0, 0, 159, 160, 1, 0, 0, 0, 160, 162, 5, 224, 0, 0,
		161, 150, 1, 0, 0, 0, 161, 162, 1, 0, 0, 0, 162, 450, 1, 0, 0, 0, 163,
		450, 5, 34, 0, 0, 164, 450, 7, 10, 0, 0, 165, 450, 5, 36, 0, 0, 166, 450,
		7, 11, 0, 0, 167, 450, 5, 40, 0, 0, 168, 450, 7, 12, 0, 0, 169, 450, 7,
		13, 0, 0, 170, 450, 5, 47, 0, 0, 171, 450, 5, 53, 0, 0, 172, 450, 5, 56,
		0, 0, 173, 450, 7, 14, 0, 0, 174, 450, 7, 15, 0, 0, 175, 450, 5, 61, 0,
		0, 176, 177, 7, 16, 0, 0, 177, 178, 5, 88, 0, 0, 178, 181, 7, 17, 0, 0,
		179, 180, 5, 283, 0, 0, 180, 182, 7, 17, 0, 0, 181, 179, 1, 0, 0, 0, 181,
		182, 1, 0, 0, 0, 182, 183, 1, 0, 0, 0, 183, 450, 5, 224, 0, 0, 184, 185,
		5, 63, 0, 0, 185, 186, 5, 88, 0, 0, 186, 189, 7, 18, 0, 0, 187, 188, 5,
		283, 0, 0, 188, 190, 7, 19, 0, 0, 189, 187, 1, 0, 0, 0, 189, 190, 1, 0,
		0, 0, 190, 191, 1, 0, 0, 0, 191, 450, 5, 224, 0, 0, 192, 450, 5, 66, 0,
		0, 193, 450, 5, 67, 0, 0, 194, 195, 5, 70, 0, 0, 195, 196, 5, 88, 0, 0,
		196, 197, 7, 20, 0, 0, 197, 450, 5, 224, 0, 0, 198, 199, 7, 21, 0, 0, 199,
		200, 5, 88, 0, 0, 200, 201, 7, 22, 0, 0, 201, 450, 5, 224, 0, 0, 202, 450,
		5, 77, 0, 0, 203, 450, 5, 78, 0, 0, 204, 450, 5, 79, 0, 0, 205, 450, 5,
		81, 0, 0, 206, 207, 7, 23, 0, 0, 207, 208, 5, 88, 0, 0, 208, 209, 3, 58,
		29, 0, 209, 210, 5, 224, 0, 0, 210, 450, 1, 0, 0, 0, 211, 450, 5, 83, 0,
		0, 212, 450, 5, 84, 0, 0, 213, 450, 5, 90, 0, 0, 214, 215, 5, 91, 0, 0,
		215, 216, 5, 88, 0, 0, 216, 217, 3, 58, 29, 0, 217, 218, 5, 283, 0, 0,
		218, 221, 3, 58, 29, 0, 219, 220, 5, 283, 0, 0, 220, 222, 3, 58, 29, 0,
		221, 219, 1, 0, 0, 0, 221, 222, 1, 0, 0, 0, 222, 223, 1, 0, 0, 0, 223,
		224, 5, 224, 0, 0, 224, 450, 1, 0, 0, 0, 225, 229, 7, 24, 0, 0, 226, 227,
		5, 88, 0, 0, 227, 228, 7, 25, 0, 0, 228, 230, 5, 224, 0, 0, 229, 226, 1,
		0, 0, 0, 229, 230, 1, 0, 0, 0, 230, 450, 1, 0, 0, 0, 231, 235, 5, 97, 0,
		0, 232, 233, 5, 88, 0, 0, 233, 234, 7, 26, 0, 0, 234, 236, 5, 224, 0, 0,
		235, 232, 1, 0, 0, 0, 235, 236, 1, 0, 0, 0, 236, 450, 1, 0, 0, 0, 237,
		238, 5, 100, 0, 0, 238, 239, 5, 88, 0, 0, 239, 240, 7, 27, 0, 0, 240, 450,
		5, 224, 0, 0, 241, 450, 5, 103, 0, 0, 242, 450, 5, 104, 0, 0, 243, 450,
		5, 106, 0, 0, 244, 450, 5, 107, 0, 0, 245, 450, 5, 109, 0, 0, 246, 450,
		5, 110, 0, 0, 247, 450, 5, 111, 0, 0, 248, 252, 7, 28, 0, 0, 249, 250,
		5, 88, 0, 0, 250, 251, 7, 29, 0, 0, 251, 253, 5, 224, 0, 0, 252, 249, 1,
		0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 450, 1, 0, 0, 0, 254, 450, 5, 113,
		0, 0, 255, 450, 7, 30, 0, 0, 256, 450, 7, 31, 0, 0, 257, 450, 5, 118, 0,
		0, 258, 450, 5, 120, 0, 0, 259, 450, 7, 32, 0, 0, 260, 450, 5, 123, 0,
		0, 261, 450, 5, 119, 0, 0, 262, 450, 7, 33, 0, 0, 263, 450, 7, 34, 0, 0,
		264, 450, 7, 35, 0, 0, 265, 450, 5, 130, 0, 0, 266, 450, 5, 132, 0, 0,
		267, 450, 5, 133, 0, 0, 268, 450, 7, 36, 0, 0, 269, 450, 7, 37, 0, 0, 270,
		450, 5, 138, 0, 0, 271, 450, 7, 38, 0, 0, 272, 450, 5, 140, 0, 0, 273,
		450, 5, 141, 0, 0, 274, 450, 5, 143, 0, 0, 275, 450, 5, 145, 0, 0, 276,
		450, 5, 146, 0, 0, 277, 450, 5, 147, 0, 0, 278, 450, 5, 148, 0, 0, 279,
		450, 5, 149, 0, 0, 280, 450, 7, 39, 0, 0, 281, 450, 5, 152, 0, 0, 282,
		450, 7, 40, 0, 0, 283, 450, 7, 41, 0, 0, 284, 450, 7, 42, 0, 0, 285, 450,
		5, 159, 0, 0, 286, 450, 7, 43, 0, 0, 287, 450, 5, 162, 0, 0, 288, 450,
		5, 163, 0, 0, 289, 450, 5, 165, 0, 0, 290, 450, 5, 166, 0, 0, 291, 450,
		7, 44, 0, 0, 292, 450, 7, 45, 0, 0, 293, 450, 5, 172, 0, 0, 294, 450, 5,
		173, 0, 0, 295, 450, 7, 46, 0, 0, 296, 450, 7, 47, 0, 0, 297, 450, 5, 178,
		0, 0, 298, 450, 7, 48, 0, 0, 299, 450, 5, 182, 0, 0, 300, 450, 5, 183,
		0, 0, 301, 450, 5, 185, 0, 0, 302, 450, 7, 49, 0, 0, 303, 450, 5, 192,
		0, 0, 304, 305, 7, 50, 0, 0, 305, 306, 5, 88, 0, 0, 306, 307, 7, 51, 0,
		0, 307, 450, 5, 224, 0, 0, 308, 450, 5, 185, 0, 0, 309, 450, 7, 52, 0,
		0, 310, 450, 5, 190, 0, 0, 311, 450, 7, 53, 0, 0, 312, 313, 5, 196, 0,
		0, 313, 314, 5, 88, 0, 0, 314, 315, 7, 54, 0, 0, 315, 450, 5, 224, 0, 0,
		316, 450, 7, 55, 0, 0, 317, 450, 7, 56, 0, 0, 318, 319, 5, 204, 0, 0, 319,
		320, 5, 88, 0, 0, 320, 321, 3, 58, 29, 0, 321, 322, 5, 283, 0, 0, 322,
		325, 3, 58, 29, 0, 323, 324, 5, 283, 0, 0, 324, 326, 3, 58, 29, 0, 325,
		323, 1, 0, 0, 0, 325, 326, 1, 0, 0, 0, 326, 327, 1, 0, 0, 0, 327, 328,
		5, 224, 0, 0, 328, 450, 1, 0, 0, 0, 329, 330, 5, 205, 0, 0, 330, 331, 5,
		88, 0, 0, 331, 332, 3, 58, 29, 0, 332, 333, 5, 283, 0, 0, 333, 334, 3,
		58, 29, 0, 334, 335, 5, 224, 0, 0, 335, 450, 1, 0, 0, 0, 336, 340, 7, 57,
		0, 0, 337, 338, 5, 88, 0, 0, 338, 339, 7, 58, 0, 0, 339, 341, 5, 224, 0,
		0, 340, 337, 1, 0, 0, 0, 340, 341, 1, 0, 0, 0, 341, 450, 1, 0, 0, 0, 342,
		450, 5, 207, 0, 0, 343, 450, 5, 209, 0, 0, 344, 450, 5, 203, 0, 0, 345,
		346, 7, 59, 0, 0, 346, 347, 5, 88, 0, 0, 347, 348, 3, 54, 27, 0, 348, 349,
		5, 224, 0, 0, 349, 450, 1, 0, 0, 0, 350, 351, 7, 60, 0, 0, 351, 352, 5,
		88, 0, 0, 352, 353, 7, 61, 0, 0, 353, 450, 5, 224, 0, 0, 354, 450, 5, 218,
		0, 0, 355, 450, 7, 62, 0, 0, 356, 450, 5, 220, 0, 0, 357, 358, 5, 223,
		0, 0, 358, 362, 5, 88, 0, 0, 359, 363, 5, 5, 0, 0, 360, 363, 5, 9, 0, 0,
		361, 363, 3, 58, 29, 0, 362, 359, 1, 0, 0, 0, 362, 360, 1, 0, 0, 0, 362,
		361, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 450, 5, 224, 0, 0, 365, 372,
		7, 63, 0, 0, 366, 367, 5, 88, 0, 0, 367, 368, 3, 58, 29, 0, 368, 369, 5,
		283, 0, 0, 369, 370, 3, 58, 29, 0, 370, 371, 5, 224, 0, 0, 371, 373, 1,
		0, 0, 0, 372, 366, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 450, 1, 0, 0,
		0, 374, 375, 7, 64, 0, 0, 375, 378, 5, 88, 0, 0, 376, 379, 5, 92, 0, 0,
		377, 379, 3, 58, 29, 0, 378, 376, 1, 0, 0, 0, 378, 377, 1, 0, 0, 0, 379,
		380, 1, 0, 0, 0, 380, 450, 5, 224, 0, 0, 381, 450, 7, 65, 0, 0, 382, 450,
		5, 232, 0, 0, 383, 384, 5, 233, 0, 0, 384, 385, 5, 88, 0, 0, 385, 386,
		3, 58, 29, 0, 386, 387, 5, 224, 0, 0, 387, 450, 1, 0, 0, 0, 388, 450, 5,
		234, 0, 0, 389, 394, 5, 235, 0, 0, 390, 391, 5, 88, 0, 0, 391, 392, 3,
		58, 29, 0, 392, 393, 5, 224, 0, 0, 393, 395, 1, 0, 0, 0, 394, 390, 1, 0,
		0, 0, 394, 395, 1, 0, 0, 0, 395, 450, 1, 0, 0, 0, 396, 450, 7, 66, 0, 0,
		397, 450, 7, 67, 0, 0, 398, 450, 5, 247, 0, 0, 399, 450, 7, 68, 0, 0, 400,
		418, 5, 251, 0, 0, 401, 403, 5, 88, 0, 0, 402, 404, 7, 69, 0, 0, 403, 402,
		1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 406, 1, 0, 0, 0, 405, 407, 5, 283,
		0, 0, 406, 405, 1, 0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 409, 1, 0, 0, 0,
		408, 410, 7, 70, 0, 0, 409, 408, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410,
		412, 1, 0, 0, 0, 411, 413, 5, 283, 0, 0, 412, 411, 1, 0, 0, 0, 412, 413,
		1, 0, 0, 0, 413, 415, 1, 0, 0, 0, 414, 416, 7, 71, 0, 0, 415, 414, 1, 0,
		0, 0, 415, 416, 1, 0, 0, 0, 416, 417, 1, 0, 0, 0, 417, 419, 5, 224, 0,
		0, 418, 401, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 450, 1, 0, 0, 0, 420,
		450, 5, 252, 0, 0, 421, 422, 5, 255, 0, 0, 422, 423, 5, 88, 0, 0, 423,
		424, 7, 72, 0, 0, 424, 450, 5, 224, 0, 0, 425, 450, 5, 258, 0, 0, 426,
		427, 7, 73, 0, 0, 427, 428, 5, 88, 0, 0, 428, 429, 3, 54, 27, 0, 429, 430,
		5, 224, 0, 0, 430, 450, 1, 0, 0, 0, 431, 432, 7, 74, 0, 0, 432, 433, 5,
		88, 0, 0, 433, 434, 7, 75, 0, 0, 434, 450, 5, 224, 0, 0, 435, 441, 7, 76,
		0, 0, 436, 438, 5, 88, 0, 0, 437, 439, 7, 77, 0, 0, 438, 437, 1, 0, 0,
		0, 438, 439, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 442, 5, 224, 0, 0,
		441, 436, 1, 0, 0, 0, 441, 442, 1, 0, 0, 0, 442, 450, 1, 0, 0, 0, 443,
		444, 7, 78, 0, 0, 444, 445, 5, 88, 0, 0, 445, 446, 3, 58, 29, 0, 446, 447,
		5, 224, 0, 0, 447, 450, 1, 0, 0, 0, 448, 450, 5, 268, 0, 0, 449, 107, 1,
		0, 0, 0, 449, 108, 1, 0, 0, 0, 449, 109, 1, 0, 0, 0, 449, 110, 1, 0, 0,
		0, 449, 114, 1, 0, 0, 0, 449, 115, 1, 0, 0, 0, 449, 116, 1, 0, 0, 0, 449,
		121, 1, 0, 0, 0, 449, 122, 1, 0, 0, 0, 449, 129, 1, 0, 0, 0, 449, 130,
		1, 0, 0, 0, 449, 131, 1, 0, 0, 0, 449, 136, 1, 0, 0, 0, 449, 137, 1, 0,
		0, 0, 449, 138, 1, 0, 0, 0, 449, 139, 1, 0, 0, 0, 449, 144, 1, 0, 0, 0,
		449, 149, 1, 0, 0, 0, 449, 163, 1, 0, 0, 0, 449, 164, 1, 0, 0, 0, 449,
		165, 1, 0, 0, 0, 449, 166, 1, 0, 0, 0, 449, 167, 1, 0, 0, 0, 449, 168,
		1, 0, 0, 0, 449, 169, 1, 0, 0, 0, 449, 170, 1, 0, 0, 0, 449, 171, 1, 0,
		0, 0, 449, 172, 1, 0, 0, 0, 449, 173, 1, 0, 0, 0, 449, 174, 1, 0, 0, 0,
		449, 175, 1, 0, 0, 0, 449, 176, 1, 0, 0, 0, 449, 184, 1, 0, 0, 0, 449,
		192, 1, 0, 0, 0, 449, 193, 1, 0, 0, 0, 449, 194, 1, 0, 0, 0, 449, 198,
		1, 0, 0, 0, 449, 202, 1, 0, 0, 0, 449, 203, 1, 0, 0, 0, 449, 204, 1, 0,
		0, 0, 449, 205, 1, 0, 0, 0, 449, 206, 1, 0, 0, 0, 449, 211, 1, 0, 0, 0,
		449, 212, 1, 0, 0, 0, 449, 213, 1, 0, 0, 0, 449, 214, 1, 0, 0, 0, 449,
		225, 1, 0, 0, 0, 449, 231, 1, 0, 0, 0, 449, 237, 1, 0, 0, 0, 449, 241,
		1, 0, 0, 0, 449, 242, 1, 0, 0, 0, 449, 243, 1, 0, 0, 0, 449, 244, 1, 0,
		0, 0, 449, 245, 1, 0, 0, 0, 449, 246, 1, 0, 0, 0, 449, 247, 1, 0, 0, 0,
		449, 248, 1, 0, 0, 0, 449, 254, 1, 0, 0, 0, 449, 255, 1, 0, 0, 0, 449,
		256, 1, 0, 0, 0, 449, 257, 1, 0, 0, 0, 449, 258, 1, 0, 0, 0, 449, 259,
		1, 0, 0, 0, 449, 260, 1, 0, 0, 0, 449, 261, 1, 0, 0, 0, 449, 262, 1, 0,
		0, 0, 449, 263, 1, 0, 0, 0, 449, 264, 1, 0, 0, 0, 449, 265, 1, 0, 0, 0,
		449, 266, 1, 0, 0, 0, 449, 267, 1, 0, 0, 0, 449, 268, 1, 0, 0, 0, 449,
		269, 1, 0, 0, 0, 449, 270, 1, 0, 0, 0, 449, 271, 1, 0, 0, 0, 449, 272,
		1, 0, 0, 0, 449, 273, 1, 0, 0, 0, 449, 274, 1, 0, 0, 0, 449, 275, 1, 0,
		0, 0, 449, 276, 1, 0, 0, 0, 449, 277, 1, 0, 0, 0, 449, 278, 1, 0, 0, 0,
		449, 279, 1, 0, 0, 0, 449, 280, 1, 0, 0, 0, 449, 281, 1, 0, 0, 0, 449,
		282, 1, 0, 0, 0, 449, 283, 1, 0, 0, 0, 449, 284, 1, 0, 0, 0, 449, 285,
		1, 0, 0, 0, 449, 286, 1, 0, 0, 0, 449, 287, 1, 0, 0, 0, 449, 288, 1, 0,
		0, 0, 449, 289, 1, 0, 0, 0, 449, 290, 1, 0, 0, 0, 449, 291, 1, 0, 0, 0,
		449, 292, 1, 0, 0, 0, 449, 293, 1, 0, 0, 0, 449, 294, 1, 0, 0, 0, 449,
		295, 1, 0, 0, 0, 449, 296, 1, 0, 0, 0, 449, 297, 1, 0, 0, 0, 449, 298,
		1, 0, 0, 0, 449, 299, 1, 0, 0, 0, 449, 300, 1, 0, 0, 0, 449, 301, 1, 0,
		0, 0, 449, 302, 1, 0, 0, 0, 449, 303, 1, 0, 0, 0, 449, 304, 1, 0, 0, 0,
		449, 308, 1, 0, 0, 0, 449, 309, 1, 0, 0, 0, 449, 310, 1, 0, 0, 0, 449,
		311, 1, 0, 0, 0, 449, 312, 1, 0, 0, 0, 449, 316, 1, 0, 0, 0, 449, 317,
		1, 0, 0, 0, 449, 318, 1, 0, 0, 0, 449, 329, 1, 0, 0, 0, 449, 336, 1, 0,
		0, 0, 449, 342, 1, 0, 0, 0, 449, 343, 1, 0, 0, 0, 449, 344, 1, 0, 0, 0,
		449, 345, 1, 0, 0, 0, 449, 350, 1, 0, 0, 0, 449, 354, 1, 0, 0, 0, 449,
		355, 1, 0, 0, 0, 449, 356, 1, 0, 0, 0, 449, 357, 1, 0, 0, 0, 449, 365,
		1, 0, 0, 0, 449, 374, 1, 0, 0, 0, 449, 381, 1, 0, 0, 0, 449, 382, 1, 0,
		0, 0, 449, 383, 1, 0, 0, 0, 449, 388, 1, 0, 0, 0, 449, 389, 1, 0, 0, 0,
		449, 396, 1, 0, 0, 0, 449, 397, 1, 0, 0, 0, 449, 398, 1, 0, 0, 0, 449,
		399, 1, 0, 0, 0, 449, 400, 1, 0, 0, 0, 449, 420, 1, 0, 0, 0, 449, 421,
		1, 0, 0, 0, 449, 425, 1, 0, 0, 0, 449, 426, 1, 0, 0, 0, 449, 431, 1, 0,
		0, 0, 449, 435, 1, 0, 0, 0, 449, 443, 1, 0, 0, 0, 449, 448, 1, 0, 0, 0,
		450, 7, 1, 0, 0, 0, 451, 452, 5, 55, 0, 0, 452, 453, 5, 18, 0, 0, 453,
		454, 3, 48, 24, 0, 454, 456, 5, 52, 0, 0, 455, 457, 5, 284, 0, 0, 456,
		455, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 9, 1, 0, 0, 0, 458, 459, 5,
		55, 0, 0, 459, 460, 5, 235, 0, 0, 460, 461, 3, 50, 25, 0, 461, 463, 5,
		52, 0, 0, 462, 464, 5, 284, 0, 0, 463, 462, 1, 0, 0, 0, 463, 464, 1, 0,
		0, 0, 464, 11, 1, 0, 0, 0, 465, 466, 5, 55, 0, 0, 466, 467, 5, 238, 0,
		0, 467, 468, 3, 48, 24, 0, 468, 470, 5, 52, 0, 0, 469, 471, 5, 284, 0,
		0, 470, 469, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471, 13, 1, 0, 0, 0, 472,
		473, 5, 25, 0, 0, 473, 489, 3, 16, 8, 0, 474, 476, 5, 291, 0, 0, 475, 474,
		1, 0, 0, 0, 476, 479, 1, 0, 0, 0, 477, 475, 1, 0, 0, 0, 477, 478, 1, 0,
		0, 0, 478, 485, 1, 0, 0, 0, 479, 477, 1, 0, 0, 0, 480, 486, 3, 32, 16,
		0, 481, 486, 3, 34, 17, 0, 482, 486, 3, 20, 10, 0, 483, 486, 3, 22, 11,
		0, 484, 486, 5, 246, 0, 0, 485, 480, 1, 0, 0, 0, 485, 481, 1, 0, 0, 0,
		485, 482, 1, 0, 0, 0, 485, 483, 1, 0, 0, 0, 485, 484, 1, 0, 0, 0, 486,
		488, 1, 0, 0, 0, 487, 477, 1, 0, 0, 0, 488, 491, 1, 0, 0, 0, 489, 487,
		1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 495, 1, 0, 0, 0, 491, 489, 1, 0,
		0, 0, 492, 494, 5, 291, 0, 0, 493, 492, 1, 0, 0, 0, 494, 497, 1, 0, 0,
		0, 495, 493, 1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 498, 1, 0, 0, 0, 497,
		495, 1, 0, 0, 0, 498, 499, 5, 284, 0, 0, 499, 15, 1, 0, 0, 0, 500, 504,
		3, 58, 29, 0, 501, 504, 3, 54, 27, 0, 502, 504, 3, 60, 30, 0, 503, 500,
		1, 0, 0, 0, 503, 501, 1, 0, 0, 0, 503, 502, 1, 0, 0, 0, 504, 507, 1, 0,
		0, 0, 505, 506, 7, 79, 0, 0, 506, 508, 3, 18, 9, 0, 507, 505, 1, 0, 0,
		0, 507, 508, 1, 0, 0, 0, 508, 17, 1, 0, 0, 0, 509, 512, 3, 58, 29, 0, 510,
		512, 3, 54, 27, 0, 511, 509, 1, 0, 0, 0, 511, 510, 1, 0, 0, 0, 512, 19,
		1, 0, 0, 0, 513, 517, 5, 216, 0, 0, 514, 516, 5, 291, 0, 0, 515, 514, 1,
		0, 0, 0, 516, 519, 1, 0, 0, 0, 517, 515, 1, 0, 0, 0, 517, 518, 1, 0, 0,
		0, 518, 520, 1, 0, 0, 0, 519, 517, 1, 0, 0, 0, 520, 521, 3, 56, 28, 0,
		521, 21, 1, 0, 0, 0, 522, 526, 5, 222, 0, 0, 523, 525, 5, 291, 0, 0, 524,
		523, 1, 0, 0, 0, 525, 528, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0, 526, 527,
		1, 0, 0, 0, 527, 529, 1, 0, 0, 0, 528, 526, 1, 0, 0, 0, 529, 538, 3, 30,
		15, 0, 530, 532, 5, 291, 0, 0, 531, 530, 1, 0, 0, 0, 532, 533, 1, 0, 0,
		0, 533, 531, 1, 0, 0, 0, 533, 534, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535,
		537, 3, 30, 15, 0, 536, 531, 1, 0, 0, 0, 537, 540, 1, 0, 0, 0, 538, 536,
		1, 0, 0, 0, 538, 539, 1, 0, 0, 0, 539, 23, 1, 0, 0, 0, 540, 538, 1, 0,
		0, 0, 541, 546, 3, 26, 13, 0, 542, 545, 3, 14, 7, 0, 543, 545, 3, 48, 24,
		0, 544, 542, 1, 0, 0, 0, 544, 543, 1, 0, 0, 0, 545, 548, 1, 0, 0, 0, 546,
		544, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 550, 1, 0, 0, 0, 548, 546,
		1, 0, 0, 0, 549, 551, 3, 28, 14, 0, 550, 549, 1, 0, 0, 0, 550, 551, 1,
		0, 0, 0, 551, 25, 1, 0, 0, 0, 552, 560, 5, 221, 0, 0, 553, 555, 5, 291,
		0, 0, 554, 553, 1, 0, 0, 0, 555, 558, 1, 0, 0, 0, 556, 554, 1, 0, 0, 0,
		556, 557, 1, 0, 0, 0, 557, 559, 1, 0, 0, 0, 558, 556, 1, 0, 0, 0, 559,
		561, 3, 30, 15, 0, 560, 556, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 560,
		1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 564, 1, 0, 0, 0, 564, 565, 5, 284,
		0, 0, 565, 27, 1, 0, 0, 0, 566, 567, 5, 221, 0, 0, 567, 568, 5, 200, 0,
		0, 568, 569, 5, 284, 0, 0, 569, 29, 1, 0, 0, 0, 570, 574, 3, 36, 18, 0,
		571, 573, 5, 291, 0, 0, 572, 571, 1, 0, 0, 0, 573, 576, 1, 0, 0, 0, 574,
		572, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 577, 1, 0, 0, 0, 576, 574,
		1, 0, 0, 0, 577, 581, 5, 15, 0, 0, 578, 580, 5, 291, 0, 0, 579, 578, 1,
		0, 0, 0, 580, 583, 1, 0, 0, 0, 581, 579, 1, 0, 0, 0, 581, 582, 1, 0, 0,
		0, 582, 584, 1, 0, 0, 0, 583, 581, 1, 0, 0, 0, 584, 592, 3, 38, 19, 0,
		585, 587, 5, 291, 0, 0, 586, 585, 1, 0, 0, 0, 587, 590, 1, 0, 0, 0, 588,
		586, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 591, 1, 0, 0, 0, 590, 588,
		1, 0, 0, 0, 591, 593, 3, 32, 16, 0, 592, 588, 1, 0, 0, 0, 592, 593, 1,
		0, 0, 0, 593, 601, 1, 0, 0, 0, 594, 596, 5, 291, 0, 0, 595, 594, 1, 0,
		0, 0, 596, 599, 1, 0, 0, 0, 597, 595, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0,
		598, 600, 1, 0, 0, 0, 599, 597, 1, 0, 0, 0, 600, 602, 3, 34, 17, 0, 601,
		597, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602, 31, 1, 0, 0, 0, 603, 607, 7,
		79, 0, 0, 604, 606, 5, 291, 0, 0, 605, 604, 1, 0, 0, 0, 606, 609, 1, 0,
		0, 0, 607, 605, 1, 0, 0, 0, 607, 608, 1, 0, 0, 0, 608, 612, 1, 0, 0, 0,
		609, 607, 1, 0, 0, 0, 610, 613, 3, 58, 29, 0, 611, 613, 3, 54, 27, 0, 612,
		610, 1, 0, 0, 0, 612, 611, 1, 0, 0, 0, 613, 33, 1, 0, 0, 0, 614, 618, 5,
		202, 0, 0, 615, 617, 5, 291, 0, 0, 616, 615, 1, 0, 0, 0, 617, 620, 1, 0,
		0, 0, 618, 616, 1, 0, 0, 0, 618, 619, 1, 0, 0, 0, 619, 623, 1, 0, 0, 0,
		620, 618, 1, 0, 0, 0, 621, 624, 3, 58, 29, 0, 622, 624, 3, 54, 27, 0, 623,
		621, 1, 0, 0, 0, 623, 622, 1, 0, 0, 0, 624, 35, 1, 0, 0, 0, 625, 630, 3,
		58, 29, 0, 626, 630, 3, 54, 27, 0, 627, 630, 3, 46, 23, 0, 628, 630, 3,
		52, 26, 0, 629, 625, 1, 0, 0, 0, 629, 626, 1, 0, 0, 0, 629, 627, 1, 0,
		0, 0, 629, 628, 1, 0, 0, 0, 630, 37, 1, 0, 0, 0, 631, 636, 3, 58, 29, 0,
		632, 636, 3, 54, 27, 0, 633, 636, 3, 46, 23, 0, 634, 636, 3, 52, 26, 0,
		635, 631, 1, 0, 0, 0, 635, 632, 1, 0, 0, 0, 635, 633, 1, 0, 0, 0, 635,
		634, 1, 0, 0, 0, 636, 39, 1, 0, 0, 0, 637, 639, 5, 48, 0, 0, 638, 640,
		5, 284, 0, 0, 639, 638, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 41, 1, 0,
		0, 0, 641, 643, 7, 80, 0, 0, 642, 644, 5, 284, 0, 0, 643, 642, 1, 0, 0,
		0, 643, 644, 1, 0, 0, 0, 644, 43, 1, 0, 0, 0, 645, 646, 5, 253, 0, 0, 646,
		648, 3, 58, 29, 0, 647, 649, 5, 284, 0, 0, 648, 647, 1, 0, 0, 0, 648, 649,
		1, 0, 0, 0, 649, 45, 1, 0, 0, 0, 650, 652, 5, 285, 0, 0, 651, 653, 3, 48,
		24, 0, 652, 651, 1, 0, 0, 0, 652, 653, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0,
		654, 655, 5, 285, 0, 0, 655, 47, 1, 0, 0, 0, 656, 659, 3, 52, 26, 0, 657,
		659, 5, 291, 0, 0, 658, 656, 1, 0, 0, 0, 658, 657, 1, 0, 0, 0, 659, 660,
		1, 0, 0, 0, 660, 658, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661, 49, 1, 0,
		0, 0, 662, 667, 3, 52, 26, 0, 663, 667, 5, 25, 0, 0, 664, 667, 5, 221,
		0, 0, 665, 667, 5, 291, 0, 0, 666, 662, 1, 0, 0, 0, 666, 663, 1, 0, 0,
		0, 666, 664, 1, 0, 0, 0, 666, 665, 1, 0, 0, 0, 667, 668, 1, 0, 0, 0, 668,
		666, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 51, 1, 0, 0, 0, 670, 678, 3,
		54, 27, 0, 671, 678, 3, 58, 29, 0, 672, 678, 3, 60, 30, 0, 673, 678, 5,
		294, 0, 0, 674, 678, 5, 284, 0, 0, 675, 678, 5, 88, 0, 0, 676, 678, 5,
		224, 0, 0, 677, 670, 1, 0, 0, 0, 677, 671, 1, 0, 0, 0, 677, 672, 1, 0,
		0, 0, 677, 673, 1, 0, 0, 0, 677, 674, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0,
		677, 676, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 679,
		680, 1, 0, 0, 0, 680, 53, 1, 0, 0, 0, 681, 684, 5, 288, 0, 0, 682, 684,
		3, 62, 31, 0, 683, 681, 1, 0, 0, 0, 683, 682, 1, 0, 0, 0, 684, 55, 1, 0,
		0, 0, 685, 686, 5, 290, 0, 0, 686, 57, 1, 0, 0, 0, 687, 688, 7, 81, 0,
		0, 688, 59, 1, 0, 0, 0, 689, 690, 5, 289, 0, 0, 690, 61, 1, 0, 0, 0, 691,
		692, 7, 82, 0, 0, 692, 63, 1, 0, 0, 0, 75, 76, 78, 85, 89, 91, 97, 102,
		127, 152, 155, 158, 161, 181, 189, 221, 229, 235, 252, 325, 340, 362, 372,
		378, 394, 403, 406, 409, 412, 415, 418, 438, 441, 449, 456, 463, 470, 477,
		485, 489, 495, 503, 507, 511, 517, 526, 533, 538, 544, 546, 550, 556, 562,
		574, 581, 588, 592, 597, 601, 607, 612, 618, 623, 629, 635, 639, 643, 648,
		652, 658, 660, 666, 668, 677, 679, 683,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// Cobol85PreprocessorParserInit initializes any static state used to implement Cobol85PreprocessorParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCobol85PreprocessorParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Cobol85PreprocessorParserInit() {
	staticData := &Cobol85PreprocessorParserStaticData
	staticData.once.Do(cobol85preprocessorParserInit)
}

// NewCobol85PreprocessorParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCobol85PreprocessorParser(input antlr.TokenStream) *Cobol85PreprocessorParser {
	Cobol85PreprocessorParserInit()
	this := new(Cobol85PreprocessorParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &Cobol85PreprocessorParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Cobol85Preprocessor.g4"

	return this
}

// Cobol85PreprocessorParser tokens.
const (
	Cobol85PreprocessorParserEOF               = antlr.TokenEOF
	Cobol85PreprocessorParserADATA             = 1
	Cobol85PreprocessorParserADV               = 2
	Cobol85PreprocessorParserALIAS             = 3
	Cobol85PreprocessorParserANSI              = 4
	Cobol85PreprocessorParserANY               = 5
	Cobol85PreprocessorParserAPOST             = 6
	Cobol85PreprocessorParserAR                = 7
	Cobol85PreprocessorParserARITH             = 8
	Cobol85PreprocessorParserAUTO              = 9
	Cobol85PreprocessorParserAWO               = 10
	Cobol85PreprocessorParserBIN               = 11
	Cobol85PreprocessorParserBLOCK0            = 12
	Cobol85PreprocessorParserBUF               = 13
	Cobol85PreprocessorParserBUFSIZE           = 14
	Cobol85PreprocessorParserBY                = 15
	Cobol85PreprocessorParserCBL               = 16
	Cobol85PreprocessorParserCBLCARD           = 17
	Cobol85PreprocessorParserCICS              = 18
	Cobol85PreprocessorParserCO                = 19
	Cobol85PreprocessorParserCOBOL2            = 20
	Cobol85PreprocessorParserCOBOL3            = 21
	Cobol85PreprocessorParserCODEPAGE          = 22
	Cobol85PreprocessorParserCOMPAT            = 23
	Cobol85PreprocessorParserCOMPILE           = 24
	Cobol85PreprocessorParserCOPY              = 25
	Cobol85PreprocessorParserCP                = 26
	Cobol85PreprocessorParserCPP               = 27
	Cobol85PreprocessorParserCPSM              = 28
	Cobol85PreprocessorParserCS                = 29
	Cobol85PreprocessorParserCURR              = 30
	Cobol85PreprocessorParserCURRENCY          = 31
	Cobol85PreprocessorParserDATA              = 32
	Cobol85PreprocessorParserDATEPROC          = 33
	Cobol85PreprocessorParserDBCS              = 34
	Cobol85PreprocessorParserDD                = 35
	Cobol85PreprocessorParserDEBUG             = 36
	Cobol85PreprocessorParserDECK              = 37
	Cobol85PreprocessorParserDIAGTRUNC         = 38
	Cobol85PreprocessorParserDLI               = 39
	Cobol85PreprocessorParserDLL               = 40
	Cobol85PreprocessorParserDP                = 41
	Cobol85PreprocessorParserDTR               = 42
	Cobol85PreprocessorParserDU                = 43
	Cobol85PreprocessorParserDUMP              = 44
	Cobol85PreprocessorParserDYN               = 45
	Cobol85PreprocessorParserDYNAM             = 46
	Cobol85PreprocessorParserEDF               = 47
	Cobol85PreprocessorParserEJECT             = 48
	Cobol85PreprocessorParserEJPD              = 49
	Cobol85PreprocessorParserEN                = 50
	Cobol85PreprocessorParserENGLISH           = 51
	Cobol85PreprocessorParserEND_EXEC          = 52
	Cobol85PreprocessorParserEPILOG            = 53
	Cobol85PreprocessorParserEXCI              = 54
	Cobol85PreprocessorParserEXEC              = 55
	Cobol85PreprocessorParserEXIT              = 56
	Cobol85PreprocessorParserEXP               = 57
	Cobol85PreprocessorParserEXPORTALL         = 58
	Cobol85PreprocessorParserEXTEND            = 59
	Cobol85PreprocessorParserFASTSRT           = 60
	Cobol85PreprocessorParserFEPI              = 61
	Cobol85PreprocessorParserFLAG              = 62
	Cobol85PreprocessorParserFLAGSTD           = 63
	Cobol85PreprocessorParserFSRT              = 64
	Cobol85PreprocessorParserFULL              = 65
	Cobol85PreprocessorParserGDS               = 66
	Cobol85PreprocessorParserGRAPHIC           = 67
	Cobol85PreprocessorParserHOOK              = 68
	Cobol85PreprocessorParserIN                = 69
	Cobol85PreprocessorParserINTDATE           = 70
	Cobol85PreprocessorParserJA                = 71
	Cobol85PreprocessorParserJP                = 72
	Cobol85PreprocessorParserKA                = 73
	Cobol85PreprocessorParserLANG              = 74
	Cobol85PreprocessorParserLANGUAGE          = 75
	Cobol85PreprocessorParserLC                = 76
	Cobol85PreprocessorParserLEASM             = 77
	Cobol85PreprocessorParserLENGTH            = 78
	Cobol85PreprocessorParserLIB               = 79
	Cobol85PreprocessorParserLILIAN            = 80
	Cobol85PreprocessorParserLIN               = 81
	Cobol85PreprocessorParserLINECOUNT         = 82
	Cobol85PreprocessorParserLINKAGE           = 83
	Cobol85PreprocessorParserLIST              = 84
	Cobol85PreprocessorParserLM                = 85
	Cobol85PreprocessorParserLONGMIXED         = 86
	Cobol85PreprocessorParserLONGUPPER         = 87
	Cobol85PreprocessorParserLPARENCHAR        = 88
	Cobol85PreprocessorParserLU                = 89
	Cobol85PreprocessorParserMAP               = 90
	Cobol85PreprocessorParserMARGINS           = 91
	Cobol85PreprocessorParserMAX               = 92
	Cobol85PreprocessorParserMD                = 93
	Cobol85PreprocessorParserMDECK             = 94
	Cobol85PreprocessorParserMIG               = 95
	Cobol85PreprocessorParserMIXED             = 96
	Cobol85PreprocessorParserNAME              = 97
	Cobol85PreprocessorParserNAT               = 98
	Cobol85PreprocessorParserNATIONAL          = 99
	Cobol85PreprocessorParserNATLANG           = 100
	Cobol85PreprocessorParserNN                = 101
	Cobol85PreprocessorParserNO                = 102
	Cobol85PreprocessorParserNOADATA           = 103
	Cobol85PreprocessorParserNOADV             = 104
	Cobol85PreprocessorParserNOALIAS           = 105
	Cobol85PreprocessorParserNOAWO             = 106
	Cobol85PreprocessorParserNOBLOCK0          = 107
	Cobol85PreprocessorParserNOC               = 108
	Cobol85PreprocessorParserNOCBLCARD         = 109
	Cobol85PreprocessorParserNOCICS            = 110
	Cobol85PreprocessorParserNOCMPR2           = 111
	Cobol85PreprocessorParserNOCOMPILE         = 112
	Cobol85PreprocessorParserNOCPSM            = 113
	Cobol85PreprocessorParserNOCURR            = 114
	Cobol85PreprocessorParserNOCURRENCY        = 115
	Cobol85PreprocessorParserNOD               = 116
	Cobol85PreprocessorParserNODATEPROC        = 117
	Cobol85PreprocessorParserNODBCS            = 118
	Cobol85PreprocessorParserNODE              = 119
	Cobol85PreprocessorParserNODEBUG           = 120
	Cobol85PreprocessorParserNODECK            = 121
	Cobol85PreprocessorParserNODIAGTRUNC       = 122
	Cobol85PreprocessorParserNODLL             = 123
	Cobol85PreprocessorParserNODU              = 124
	Cobol85PreprocessorParserNODUMP            = 125
	Cobol85PreprocessorParserNODP              = 126
	Cobol85PreprocessorParserNODTR             = 127
	Cobol85PreprocessorParserNODYN             = 128
	Cobol85PreprocessorParserNODYNAM           = 129
	Cobol85PreprocessorParserNOEDF             = 130
	Cobol85PreprocessorParserNOEJPD            = 131
	Cobol85PreprocessorParserNOEPILOG          = 132
	Cobol85PreprocessorParserNOEXIT            = 133
	Cobol85PreprocessorParserNOEXP             = 134
	Cobol85PreprocessorParserNOEXPORTALL       = 135
	Cobol85PreprocessorParserNOF               = 136
	Cobol85PreprocessorParserNOFASTSRT         = 137
	Cobol85PreprocessorParserNOFEPI            = 138
	Cobol85PreprocessorParserNOFLAG            = 139
	Cobol85PreprocessorParserNOFLAGMIG         = 140
	Cobol85PreprocessorParserNOFLAGSTD         = 141
	Cobol85PreprocessorParserNOFSRT            = 142
	Cobol85PreprocessorParserNOGRAPHIC         = 143
	Cobol85PreprocessorParserNOHOOK            = 144
	Cobol85PreprocessorParserNOLENGTH          = 145
	Cobol85PreprocessorParserNOLIB             = 146
	Cobol85PreprocessorParserNOLINKAGE         = 147
	Cobol85PreprocessorParserNOLIST            = 148
	Cobol85PreprocessorParserNOMAP             = 149
	Cobol85PreprocessorParserNOMD              = 150
	Cobol85PreprocessorParserNOMDECK           = 151
	Cobol85PreprocessorParserNONAME            = 152
	Cobol85PreprocessorParserNONUM             = 153
	Cobol85PreprocessorParserNONUMBER          = 154
	Cobol85PreprocessorParserNOOBJ             = 155
	Cobol85PreprocessorParserNOOBJECT          = 156
	Cobol85PreprocessorParserNOOFF             = 157
	Cobol85PreprocessorParserNOOFFSET          = 158
	Cobol85PreprocessorParserNOOPSEQUENCE      = 159
	Cobol85PreprocessorParserNOOPT             = 160
	Cobol85PreprocessorParserNOOPTIMIZE        = 161
	Cobol85PreprocessorParserNOOPTIONS         = 162
	Cobol85PreprocessorParserNOP               = 163
	Cobol85PreprocessorParserNOPFD             = 164
	Cobol85PreprocessorParserNOPROLOG          = 165
	Cobol85PreprocessorParserNORENT            = 166
	Cobol85PreprocessorParserNOS               = 167
	Cobol85PreprocessorParserNOSEP             = 168
	Cobol85PreprocessorParserNOSEPARATE        = 169
	Cobol85PreprocessorParserNOSEQ             = 170
	Cobol85PreprocessorParserNOSOURCE          = 171
	Cobol85PreprocessorParserNOSPIE            = 172
	Cobol85PreprocessorParserNOSQL             = 173
	Cobol85PreprocessorParserNOSQLC            = 174
	Cobol85PreprocessorParserNOSQLCCSID        = 175
	Cobol85PreprocessorParserNOSSR             = 176
	Cobol85PreprocessorParserNOSSRANGE         = 177
	Cobol85PreprocessorParserNOSTDTRUNC        = 178
	Cobol85PreprocessorParserNOSEQUENCE        = 179
	Cobol85PreprocessorParserNOTERM            = 180
	Cobol85PreprocessorParserNOTERMINAL        = 181
	Cobol85PreprocessorParserNOTEST            = 182
	Cobol85PreprocessorParserNOTHREAD          = 183
	Cobol85PreprocessorParserNOTRIG            = 184
	Cobol85PreprocessorParserNOVBREF           = 185
	Cobol85PreprocessorParserNOWD              = 186
	Cobol85PreprocessorParserNOWORD            = 187
	Cobol85PreprocessorParserNOX               = 188
	Cobol85PreprocessorParserNOXREF            = 189
	Cobol85PreprocessorParserNOZWB             = 190
	Cobol85PreprocessorParserNS                = 191
	Cobol85PreprocessorParserNSEQ              = 192
	Cobol85PreprocessorParserNSYMBOL           = 193
	Cobol85PreprocessorParserNUM               = 194
	Cobol85PreprocessorParserNUMBER            = 195
	Cobol85PreprocessorParserNUMPROC           = 196
	Cobol85PreprocessorParserOBJ               = 197
	Cobol85PreprocessorParserOBJECT            = 198
	Cobol85PreprocessorParserOF                = 199
	Cobol85PreprocessorParserOFF               = 200
	Cobol85PreprocessorParserOFFSET            = 201
	Cobol85PreprocessorParserON                = 202
	Cobol85PreprocessorParserOP                = 203
	Cobol85PreprocessorParserOPMARGINS         = 204
	Cobol85PreprocessorParserOPSEQUENCE        = 205
	Cobol85PreprocessorParserOPT               = 206
	Cobol85PreprocessorParserOPTFILE           = 207
	Cobol85PreprocessorParserOPTIMIZE          = 208
	Cobol85PreprocessorParserOPTIONS           = 209
	Cobol85PreprocessorParserOUT               = 210
	Cobol85PreprocessorParserOUTDD             = 211
	Cobol85PreprocessorParserPFD               = 212
	Cobol85PreprocessorParserPPTDBG            = 213
	Cobol85PreprocessorParserPGMN              = 214
	Cobol85PreprocessorParserPGMNAME           = 215
	Cobol85PreprocessorParserPREFIXING         = 216
	Cobol85PreprocessorParserPROCESS           = 217
	Cobol85PreprocessorParserPROLOG            = 218
	Cobol85PreprocessorParserQUOTE             = 219
	Cobol85PreprocessorParserRENT              = 220
	Cobol85PreprocessorParserREPLACE           = 221
	Cobol85PreprocessorParserREPLACING         = 222
	Cobol85PreprocessorParserRMODE             = 223
	Cobol85PreprocessorParserRPARENCHAR        = 224
	Cobol85PreprocessorParserSEP               = 225
	Cobol85PreprocessorParserSEPARATE          = 226
	Cobol85PreprocessorParserSEQ               = 227
	Cobol85PreprocessorParserSEQUENCE          = 228
	Cobol85PreprocessorParserSHORT             = 229
	Cobol85PreprocessorParserSIZE              = 230
	Cobol85PreprocessorParserSOURCE            = 231
	Cobol85PreprocessorParserSP                = 232
	Cobol85PreprocessorParserSPACE             = 233
	Cobol85PreprocessorParserSPIE              = 234
	Cobol85PreprocessorParserSQL               = 235
	Cobol85PreprocessorParserSQLC              = 236
	Cobol85PreprocessorParserSQLCCSID          = 237
	Cobol85PreprocessorParserSQLIMS            = 238
	Cobol85PreprocessorParserSKIP1             = 239
	Cobol85PreprocessorParserSKIP2             = 240
	Cobol85PreprocessorParserSKIP3             = 241
	Cobol85PreprocessorParserSS                = 242
	Cobol85PreprocessorParserSSR               = 243
	Cobol85PreprocessorParserSSRANGE           = 244
	Cobol85PreprocessorParserSTD               = 245
	Cobol85PreprocessorParserSUPPRESS          = 246
	Cobol85PreprocessorParserSYSEIB            = 247
	Cobol85PreprocessorParserSZ                = 248
	Cobol85PreprocessorParserTERM              = 249
	Cobol85PreprocessorParserTERMINAL          = 250
	Cobol85PreprocessorParserTEST              = 251
	Cobol85PreprocessorParserTHREAD            = 252
	Cobol85PreprocessorParserTITLE             = 253
	Cobol85PreprocessorParserTRIG              = 254
	Cobol85PreprocessorParserTRUNC             = 255
	Cobol85PreprocessorParserUE                = 256
	Cobol85PreprocessorParserUPPER             = 257
	Cobol85PreprocessorParserVBREF             = 258
	Cobol85PreprocessorParserWD                = 259
	Cobol85PreprocessorParserWORD              = 260
	Cobol85PreprocessorParserXMLPARSE          = 261
	Cobol85PreprocessorParserXMLSS             = 262
	Cobol85PreprocessorParserXOPTS             = 263
	Cobol85PreprocessorParserXP                = 264
	Cobol85PreprocessorParserXREF              = 265
	Cobol85PreprocessorParserYEARWINDOW        = 266
	Cobol85PreprocessorParserYW                = 267
	Cobol85PreprocessorParserZWB               = 268
	Cobol85PreprocessorParserC_CHAR            = 269
	Cobol85PreprocessorParserD_CHAR            = 270
	Cobol85PreprocessorParserE_CHAR            = 271
	Cobol85PreprocessorParserF_CHAR            = 272
	Cobol85PreprocessorParserH_CHAR            = 273
	Cobol85PreprocessorParserI_CHAR            = 274
	Cobol85PreprocessorParserM_CHAR            = 275
	Cobol85PreprocessorParserN_CHAR            = 276
	Cobol85PreprocessorParserQ_CHAR            = 277
	Cobol85PreprocessorParserS_CHAR            = 278
	Cobol85PreprocessorParserU_CHAR            = 279
	Cobol85PreprocessorParserW_CHAR            = 280
	Cobol85PreprocessorParserX_CHAR            = 281
	Cobol85PreprocessorParserCOMMENTTAG        = 282
	Cobol85PreprocessorParserCOMMACHAR         = 283
	Cobol85PreprocessorParserDOT               = 284
	Cobol85PreprocessorParserDOUBLEEQUALCHAR   = 285
	Cobol85PreprocessorParserNONNUMERICLITERAL = 286
	Cobol85PreprocessorParserNUMERICLITERAL    = 287
	Cobol85PreprocessorParserIDENTIFIER        = 288
	Cobol85PreprocessorParserFILENAME          = 289
	Cobol85PreprocessorParserPREFIX            = 290
	Cobol85PreprocessorParserNEWLINE           = 291
	Cobol85PreprocessorParserCOMMENTLINE       = 292
	Cobol85PreprocessorParserWS                = 293
	Cobol85PreprocessorParserTEXT              = 294
)

// Cobol85PreprocessorParser rules.
const (
	Cobol85PreprocessorParserRULE_startRule           = 0
	Cobol85PreprocessorParserRULE_compilerOptions     = 1
	Cobol85PreprocessorParserRULE_compilerXOpts       = 2
	Cobol85PreprocessorParserRULE_compilerOption      = 3
	Cobol85PreprocessorParserRULE_execCicsStatement   = 4
	Cobol85PreprocessorParserRULE_execSqlStatement    = 5
	Cobol85PreprocessorParserRULE_execSqlImsStatement = 6
	Cobol85PreprocessorParserRULE_copyStatement       = 7
	Cobol85PreprocessorParserRULE_copySource          = 8
	Cobol85PreprocessorParserRULE_copyLibrary         = 9
	Cobol85PreprocessorParserRULE_prefixingPhrase     = 10
	Cobol85PreprocessorParserRULE_replacingPhrase     = 11
	Cobol85PreprocessorParserRULE_replaceArea         = 12
	Cobol85PreprocessorParserRULE_replaceByStatement  = 13
	Cobol85PreprocessorParserRULE_replaceOffStatement = 14
	Cobol85PreprocessorParserRULE_replaceClause       = 15
	Cobol85PreprocessorParserRULE_directoryPhrase     = 16
	Cobol85PreprocessorParserRULE_familyPhrase        = 17
	Cobol85PreprocessorParserRULE_replaceable         = 18
	Cobol85PreprocessorParserRULE_replacement         = 19
	Cobol85PreprocessorParserRULE_ejectStatement      = 20
	Cobol85PreprocessorParserRULE_skipStatement       = 21
	Cobol85PreprocessorParserRULE_titleStatement      = 22
	Cobol85PreprocessorParserRULE_pseudoText          = 23
	Cobol85PreprocessorParserRULE_charData            = 24
	Cobol85PreprocessorParserRULE_charDataSql         = 25
	Cobol85PreprocessorParserRULE_charDataLine        = 26
	Cobol85PreprocessorParserRULE_cobolWord           = 27
	Cobol85PreprocessorParserRULE_prefixWord          = 28
	Cobol85PreprocessorParserRULE_literal             = 29
	Cobol85PreprocessorParserRULE_filename            = 30
	Cobol85PreprocessorParserRULE_charDataKeyword     = 31
)

// IStartRuleContext is an interface to support dynamic dispatch.
type IStartRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllCompilerOptions() []ICompilerOptionsContext
	CompilerOptions(i int) ICompilerOptionsContext
	AllCopyStatement() []ICopyStatementContext
	CopyStatement(i int) ICopyStatementContext
	AllExecCicsStatement() []IExecCicsStatementContext
	ExecCicsStatement(i int) IExecCicsStatementContext
	AllExecSqlStatement() []IExecSqlStatementContext
	ExecSqlStatement(i int) IExecSqlStatementContext
	AllExecSqlImsStatement() []IExecSqlImsStatementContext
	ExecSqlImsStatement(i int) IExecSqlImsStatementContext
	AllReplaceOffStatement() []IReplaceOffStatementContext
	ReplaceOffStatement(i int) IReplaceOffStatementContext
	AllReplaceArea() []IReplaceAreaContext
	ReplaceArea(i int) IReplaceAreaContext
	AllEjectStatement() []IEjectStatementContext
	EjectStatement(i int) IEjectStatementContext
	AllSkipStatement() []ISkipStatementContext
	SkipStatement(i int) ISkipStatementContext
	AllTitleStatement() []ITitleStatementContext
	TitleStatement(i int) ITitleStatementContext
	AllCharDataLine() []ICharDataLineContext
	CharDataLine(i int) ICharDataLineContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsStartRuleContext differentiates from other interfaces.
	IsStartRuleContext()
}

type StartRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartRuleContext() *StartRuleContext {
	var p = new(StartRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_startRule
	return p
}

func InitEmptyStartRuleContext(p *StartRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_startRule
}

func (*StartRuleContext) IsStartRuleContext() {}

func NewStartRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartRuleContext {
	var p = new(StartRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_startRule

	return p
}

func (s *StartRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *StartRuleContext) EOF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEOF, 0)
}

func (s *StartRuleContext) AllCompilerOptions() []ICompilerOptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompilerOptionsContext); ok {
			len++
		}
	}

	tst := make([]ICompilerOptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompilerOptionsContext); ok {
			tst[i] = t.(ICompilerOptionsContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) CompilerOptions(i int) ICompilerOptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerOptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerOptionsContext)
}

func (s *StartRuleContext) AllCopyStatement() []ICopyStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopyStatementContext); ok {
			len++
		}
	}

	tst := make([]ICopyStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopyStatementContext); ok {
			tst[i] = t.(ICopyStatementContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) CopyStatement(i int) ICopyStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopyStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopyStatementContext)
}

func (s *StartRuleContext) AllExecCicsStatement() []IExecCicsStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExecCicsStatementContext); ok {
			len++
		}
	}

	tst := make([]IExecCicsStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExecCicsStatementContext); ok {
			tst[i] = t.(IExecCicsStatementContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) ExecCicsStatement(i int) IExecCicsStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecCicsStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecCicsStatementContext)
}

func (s *StartRuleContext) AllExecSqlStatement() []IExecSqlStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExecSqlStatementContext); ok {
			len++
		}
	}

	tst := make([]IExecSqlStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExecSqlStatementContext); ok {
			tst[i] = t.(IExecSqlStatementContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) ExecSqlStatement(i int) IExecSqlStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecSqlStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecSqlStatementContext)
}

func (s *StartRuleContext) AllExecSqlImsStatement() []IExecSqlImsStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExecSqlImsStatementContext); ok {
			len++
		}
	}

	tst := make([]IExecSqlImsStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExecSqlImsStatementContext); ok {
			tst[i] = t.(IExecSqlImsStatementContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) ExecSqlImsStatement(i int) IExecSqlImsStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecSqlImsStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecSqlImsStatementContext)
}

func (s *StartRuleContext) AllReplaceOffStatement() []IReplaceOffStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplaceOffStatementContext); ok {
			len++
		}
	}

	tst := make([]IReplaceOffStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplaceOffStatementContext); ok {
			tst[i] = t.(IReplaceOffStatementContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) ReplaceOffStatement(i int) IReplaceOffStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceOffStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceOffStatementContext)
}

func (s *StartRuleContext) AllReplaceArea() []IReplaceAreaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplaceAreaContext); ok {
			len++
		}
	}

	tst := make([]IReplaceAreaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplaceAreaContext); ok {
			tst[i] = t.(IReplaceAreaContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) ReplaceArea(i int) IReplaceAreaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceAreaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceAreaContext)
}

func (s *StartRuleContext) AllEjectStatement() []IEjectStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEjectStatementContext); ok {
			len++
		}
	}

	tst := make([]IEjectStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEjectStatementContext); ok {
			tst[i] = t.(IEjectStatementContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) EjectStatement(i int) IEjectStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEjectStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEjectStatementContext)
}

func (s *StartRuleContext) AllSkipStatement() []ISkipStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISkipStatementContext); ok {
			len++
		}
	}

	tst := make([]ISkipStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISkipStatementContext); ok {
			tst[i] = t.(ISkipStatementContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) SkipStatement(i int) ISkipStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipStatementContext)
}

func (s *StartRuleContext) AllTitleStatement() []ITitleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITitleStatementContext); ok {
			len++
		}
	}

	tst := make([]ITitleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITitleStatementContext); ok {
			tst[i] = t.(ITitleStatementContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) TitleStatement(i int) ITitleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITitleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITitleStatementContext)
}

func (s *StartRuleContext) AllCharDataLine() []ICharDataLineContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICharDataLineContext); ok {
			len++
		}
	}

	tst := make([]ICharDataLineContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICharDataLineContext); ok {
			tst[i] = t.(ICharDataLineContext)
			i++
		}
	}

	return tst
}

func (s *StartRuleContext) CharDataLine(i int) ICharDataLineContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataLineContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataLineContext)
}

func (s *StartRuleContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *StartRuleContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *StartRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterStartRule(s)
	}
}

func (s *StartRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitStartRule(s)
	}
}

func (s *StartRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitStartRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) StartRule() (localctx IStartRuleContext) {
	localctx = NewStartRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Cobol85PreprocessorParserRULE_startRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(78)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2310346608841326594) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8193) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-288230376151711745) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-18084767270436865) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&325813534447) != 0) {
		p.SetState(76)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(64)
				p.CompilerOptions()
			}

		case 2:
			{
				p.SetState(65)
				p.CopyStatement()
			}

		case 3:
			{
				p.SetState(66)
				p.ExecCicsStatement()
			}

		case 4:
			{
				p.SetState(67)
				p.ExecSqlStatement()
			}

		case 5:
			{
				p.SetState(68)
				p.ExecSqlImsStatement()
			}

		case 6:
			{
				p.SetState(69)
				p.ReplaceOffStatement()
			}

		case 7:
			{
				p.SetState(70)
				p.ReplaceArea()
			}

		case 8:
			{
				p.SetState(71)
				p.EjectStatement()
			}

		case 9:
			{
				p.SetState(72)
				p.SkipStatement()
			}

		case 10:
			{
				p.SetState(73)
				p.TitleStatement()
			}

		case 11:
			{
				p.SetState(74)
				p.CharDataLine()
			}

		case 12:
			{
				p.SetState(75)
				p.Match(Cobol85PreprocessorParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(80)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(81)
		p.Match(Cobol85PreprocessorParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompilerOptionsContext is an interface to support dynamic dispatch.
type ICompilerOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCESS() antlr.TerminalNode
	CBL() antlr.TerminalNode
	AllCompilerOption() []ICompilerOptionContext
	CompilerOption(i int) ICompilerOptionContext
	AllCompilerXOpts() []ICompilerXOptsContext
	CompilerXOpts(i int) ICompilerXOptsContext
	AllCOMMACHAR() []antlr.TerminalNode
	COMMACHAR(i int) antlr.TerminalNode

	// IsCompilerOptionsContext differentiates from other interfaces.
	IsCompilerOptionsContext()
}

type CompilerOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilerOptionsContext() *CompilerOptionsContext {
	var p = new(CompilerOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerOptions
	return p
}

func InitEmptyCompilerOptionsContext(p *CompilerOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerOptions
}

func (*CompilerOptionsContext) IsCompilerOptionsContext() {}

func NewCompilerOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilerOptionsContext {
	var p = new(CompilerOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerOptions

	return p
}

func (s *CompilerOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilerOptionsContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPROCESS, 0)
}

func (s *CompilerOptionsContext) CBL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCBL, 0)
}

func (s *CompilerOptionsContext) AllCompilerOption() []ICompilerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompilerOptionContext); ok {
			len++
		}
	}

	tst := make([]ICompilerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompilerOptionContext); ok {
			tst[i] = t.(ICompilerOptionContext)
			i++
		}
	}

	return tst
}

func (s *CompilerOptionsContext) CompilerOption(i int) ICompilerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerOptionContext)
}

func (s *CompilerOptionsContext) AllCompilerXOpts() []ICompilerXOptsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompilerXOptsContext); ok {
			len++
		}
	}

	tst := make([]ICompilerXOptsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompilerXOptsContext); ok {
			tst[i] = t.(ICompilerXOptsContext)
			i++
		}
	}

	return tst
}

func (s *CompilerOptionsContext) CompilerXOpts(i int) ICompilerXOptsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerXOptsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerXOptsContext)
}

func (s *CompilerOptionsContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserCOMMACHAR)
}

func (s *CompilerOptionsContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOMMACHAR, i)
}

func (s *CompilerOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilerOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilerOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCompilerOptions(s)
	}
}

func (s *CompilerOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCompilerOptions(s)
	}
}

func (s *CompilerOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCompilerOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CompilerOptions() (localctx ICompilerOptionsContext) {
	localctx = NewCompilerOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Cobol85PreprocessorParserRULE_compilerOptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(83)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85PreprocessorParserCBL || _la == Cobol85PreprocessorParserPROCESS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(89)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(89)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCICS, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFEPI, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLEASM, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWD, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserWORD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXP, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR:
				p.SetState(85)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == Cobol85PreprocessorParserCOMMACHAR {
					{
						p.SetState(84)
						p.Match(Cobol85PreprocessorParserCOMMACHAR)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(87)
					p.CompilerOption()
				}

			case Cobol85PreprocessorParserXOPTS:
				{
					p.SetState(88)
					p.CompilerXOpts()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(91)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompilerXOptsContext is an interface to support dynamic dispatch.
type ICompilerXOptsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XOPTS() antlr.TerminalNode
	LPARENCHAR() antlr.TerminalNode
	AllCompilerOption() []ICompilerOptionContext
	CompilerOption(i int) ICompilerOptionContext
	RPARENCHAR() antlr.TerminalNode
	AllCOMMACHAR() []antlr.TerminalNode
	COMMACHAR(i int) antlr.TerminalNode

	// IsCompilerXOptsContext differentiates from other interfaces.
	IsCompilerXOptsContext()
}

type CompilerXOptsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilerXOptsContext() *CompilerXOptsContext {
	var p = new(CompilerXOptsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerXOpts
	return p
}

func InitEmptyCompilerXOptsContext(p *CompilerXOptsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerXOpts
}

func (*CompilerXOptsContext) IsCompilerXOptsContext() {}

func NewCompilerXOptsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilerXOptsContext {
	var p = new(CompilerXOptsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerXOpts

	return p
}

func (s *CompilerXOptsContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilerXOptsContext) XOPTS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXOPTS, 0)
}

func (s *CompilerXOptsContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLPARENCHAR, 0)
}

func (s *CompilerXOptsContext) AllCompilerOption() []ICompilerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompilerOptionContext); ok {
			len++
		}
	}

	tst := make([]ICompilerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompilerOptionContext); ok {
			tst[i] = t.(ICompilerOptionContext)
			i++
		}
	}

	return tst
}

func (s *CompilerXOptsContext) CompilerOption(i int) ICompilerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerOptionContext)
}

func (s *CompilerXOptsContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserRPARENCHAR, 0)
}

func (s *CompilerXOptsContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserCOMMACHAR)
}

func (s *CompilerXOptsContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOMMACHAR, i)
}

func (s *CompilerXOptsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilerXOptsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilerXOptsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCompilerXOpts(s)
	}
}

func (s *CompilerXOptsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCompilerXOpts(s)
	}
}

func (s *CompilerXOptsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCompilerXOpts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CompilerXOpts() (localctx ICompilerXOptsContext) {
	localctx = NewCompilerXOptsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Cobol85PreprocessorParserRULE_compilerXOpts)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(93)
		p.Match(Cobol85PreprocessorParserXOPTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(94)
		p.Match(Cobol85PreprocessorParserLPARENCHAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(95)
		p.CompilerOption()
	}
	p.SetState(102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-639230256804891194) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-2669655688115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-72060961292353545) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-6946732225642628225) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&43540431) != 0) {
		p.SetState(97)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85PreprocessorParserCOMMACHAR {
			{
				p.SetState(96)
				p.Match(Cobol85PreprocessorParserCOMMACHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(99)
			p.CompilerOption()
		}

		p.SetState(104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(105)
		p.Match(Cobol85PreprocessorParserRPARENCHAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompilerOptionContext is an interface to support dynamic dispatch.
type ICompilerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADATA() antlr.TerminalNode
	ADV() antlr.TerminalNode
	APOST() antlr.TerminalNode
	LPARENCHAR() antlr.TerminalNode
	RPARENCHAR() antlr.TerminalNode
	ARITH() antlr.TerminalNode
	AR() antlr.TerminalNode
	EXTEND() antlr.TerminalNode
	AllE_CHAR() []antlr.TerminalNode
	E_CHAR(i int) antlr.TerminalNode
	COMPAT() antlr.TerminalNode
	C_CHAR() antlr.TerminalNode
	AWO() antlr.TerminalNode
	BLOCK0() antlr.TerminalNode
	AllLiteral() []ILiteralContext
	Literal(i int) ILiteralContext
	BUFSIZE() antlr.TerminalNode
	BUF() antlr.TerminalNode
	CBLCARD() antlr.TerminalNode
	CICS() antlr.TerminalNode
	COBOL2() antlr.TerminalNode
	COBOL3() antlr.TerminalNode
	CODEPAGE() antlr.TerminalNode
	CP() antlr.TerminalNode
	COMPILE() antlr.TerminalNode
	CPP() antlr.TerminalNode
	CPSM() antlr.TerminalNode
	CURRENCY() antlr.TerminalNode
	CURR() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATEPROC() antlr.TerminalNode
	DP() antlr.TerminalNode
	AllCOMMACHAR() []antlr.TerminalNode
	COMMACHAR(i int) antlr.TerminalNode
	FLAG() antlr.TerminalNode
	NOFLAG() antlr.TerminalNode
	TRIG() antlr.TerminalNode
	NOTRIG() antlr.TerminalNode
	DBCS() antlr.TerminalNode
	DECK() antlr.TerminalNode
	D_CHAR() antlr.TerminalNode
	DEBUG() antlr.TerminalNode
	DIAGTRUNC() antlr.TerminalNode
	DTR() antlr.TerminalNode
	DLL() antlr.TerminalNode
	DUMP() antlr.TerminalNode
	DU() antlr.TerminalNode
	DYNAM() antlr.TerminalNode
	DYN() antlr.TerminalNode
	EDF() antlr.TerminalNode
	EPILOG() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	EXPORTALL() antlr.TerminalNode
	EXP() antlr.TerminalNode
	FASTSRT() antlr.TerminalNode
	FSRT() antlr.TerminalNode
	FEPI() antlr.TerminalNode
	F_CHAR() antlr.TerminalNode
	AllI_CHAR() []antlr.TerminalNode
	I_CHAR(i int) antlr.TerminalNode
	AllS_CHAR() []antlr.TerminalNode
	S_CHAR(i int) antlr.TerminalNode
	AllU_CHAR() []antlr.TerminalNode
	U_CHAR(i int) antlr.TerminalNode
	AllW_CHAR() []antlr.TerminalNode
	W_CHAR(i int) antlr.TerminalNode
	FLAGSTD() antlr.TerminalNode
	M_CHAR() antlr.TerminalNode
	H_CHAR() antlr.TerminalNode
	DD() antlr.TerminalNode
	N_CHAR() antlr.TerminalNode
	NN() antlr.TerminalNode
	SS() antlr.TerminalNode
	GDS() antlr.TerminalNode
	GRAPHIC() antlr.TerminalNode
	INTDATE() antlr.TerminalNode
	ANSI() antlr.TerminalNode
	LILIAN() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LANG() antlr.TerminalNode
	ENGLISH() antlr.TerminalNode
	CS() antlr.TerminalNode
	EN() antlr.TerminalNode
	JA() antlr.TerminalNode
	JP() antlr.TerminalNode
	KA() antlr.TerminalNode
	UE() antlr.TerminalNode
	LEASM() antlr.TerminalNode
	LENGTH() antlr.TerminalNode
	LIB() antlr.TerminalNode
	LIN() antlr.TerminalNode
	LINECOUNT() antlr.TerminalNode
	LC() antlr.TerminalNode
	LINKAGE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MARGINS() antlr.TerminalNode
	MDECK() antlr.TerminalNode
	MD() antlr.TerminalNode
	NOC() antlr.TerminalNode
	NOCOMPILE() antlr.TerminalNode
	NAME() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	NOALIAS() antlr.TerminalNode
	NATLANG() antlr.TerminalNode
	NOADATA() antlr.TerminalNode
	NOADV() antlr.TerminalNode
	NOAWO() antlr.TerminalNode
	NOBLOCK0() antlr.TerminalNode
	NOCBLCARD() antlr.TerminalNode
	NOCICS() antlr.TerminalNode
	NOCMPR2() antlr.TerminalNode
	NOCPSM() antlr.TerminalNode
	NOCURRENCY() antlr.TerminalNode
	NOCURR() antlr.TerminalNode
	NODATEPROC() antlr.TerminalNode
	NODP() antlr.TerminalNode
	NODBCS() antlr.TerminalNode
	NODEBUG() antlr.TerminalNode
	NODECK() antlr.TerminalNode
	NOD() antlr.TerminalNode
	NODLL() antlr.TerminalNode
	NODE() antlr.TerminalNode
	NODUMP() antlr.TerminalNode
	NODU() antlr.TerminalNode
	NODIAGTRUNC() antlr.TerminalNode
	NODTR() antlr.TerminalNode
	NODYNAM() antlr.TerminalNode
	NODYN() antlr.TerminalNode
	NOEDF() antlr.TerminalNode
	NOEPILOG() antlr.TerminalNode
	NOEXIT() antlr.TerminalNode
	NOEXPORTALL() antlr.TerminalNode
	NOEXP() antlr.TerminalNode
	NOFASTSRT() antlr.TerminalNode
	NOFSRT() antlr.TerminalNode
	NOFEPI() antlr.TerminalNode
	NOF() antlr.TerminalNode
	NOFLAGMIG() antlr.TerminalNode
	NOFLAGSTD() antlr.TerminalNode
	NOGRAPHIC() antlr.TerminalNode
	NOLENGTH() antlr.TerminalNode
	NOLIB() antlr.TerminalNode
	NOLINKAGE() antlr.TerminalNode
	NOLIST() antlr.TerminalNode
	NOMAP() antlr.TerminalNode
	NOMDECK() antlr.TerminalNode
	NOMD() antlr.TerminalNode
	NONAME() antlr.TerminalNode
	NONUMBER() antlr.TerminalNode
	NONUM() antlr.TerminalNode
	NOOBJECT() antlr.TerminalNode
	NOOBJ() antlr.TerminalNode
	NOOFFSET() antlr.TerminalNode
	NOOFF() antlr.TerminalNode
	NOOPSEQUENCE() antlr.TerminalNode
	NOOPTIMIZE() antlr.TerminalNode
	NOOPT() antlr.TerminalNode
	NOOPTIONS() antlr.TerminalNode
	NOP() antlr.TerminalNode
	NOPROLOG() antlr.TerminalNode
	NORENT() antlr.TerminalNode
	NOSEQUENCE() antlr.TerminalNode
	NOSEQ() antlr.TerminalNode
	NOSOURCE() antlr.TerminalNode
	NOS() antlr.TerminalNode
	NOSPIE() antlr.TerminalNode
	NOSQL() antlr.TerminalNode
	NOSQLCCSID() antlr.TerminalNode
	NOSQLC() antlr.TerminalNode
	NOSSRANGE() antlr.TerminalNode
	NOSSR() antlr.TerminalNode
	NOSTDTRUNC() antlr.TerminalNode
	NOTERMINAL() antlr.TerminalNode
	NOTERM() antlr.TerminalNode
	NOTEST() antlr.TerminalNode
	NOTHREAD() antlr.TerminalNode
	NOVBREF() antlr.TerminalNode
	NOWORD() antlr.TerminalNode
	NOWD() antlr.TerminalNode
	NSEQ() antlr.TerminalNode
	NSYMBOL() antlr.TerminalNode
	NS() antlr.TerminalNode
	NATIONAL() antlr.TerminalNode
	NAT() antlr.TerminalNode
	NOXREF() antlr.TerminalNode
	NOX() antlr.TerminalNode
	NOZWB() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	NUM() antlr.TerminalNode
	NUMPROC() antlr.TerminalNode
	MIG() antlr.TerminalNode
	NOPFD() antlr.TerminalNode
	PFD() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	OBJ() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OFF() antlr.TerminalNode
	OPMARGINS() antlr.TerminalNode
	OPSEQUENCE() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	OPT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	STD() antlr.TerminalNode
	OPTFILE() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	OP() antlr.TerminalNode
	CobolWord() ICobolWordContext
	OUTDD() antlr.TerminalNode
	OUT() antlr.TerminalNode
	PGMNAME() antlr.TerminalNode
	PGMN() antlr.TerminalNode
	CO() antlr.TerminalNode
	LM() antlr.TerminalNode
	LONGMIXED() antlr.TerminalNode
	LONGUPPER() antlr.TerminalNode
	LU() antlr.TerminalNode
	MIXED() antlr.TerminalNode
	UPPER() antlr.TerminalNode
	PROLOG() antlr.TerminalNode
	QUOTE() antlr.TerminalNode
	Q_CHAR() antlr.TerminalNode
	RENT() antlr.TerminalNode
	RMODE() antlr.TerminalNode
	ANY() antlr.TerminalNode
	AUTO() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	SEQ() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	SZ() antlr.TerminalNode
	MAX() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SP() antlr.TerminalNode
	SPACE() antlr.TerminalNode
	SPIE() antlr.TerminalNode
	SQL() antlr.TerminalNode
	SQLCCSID() antlr.TerminalNode
	SQLC() antlr.TerminalNode
	SSRANGE() antlr.TerminalNode
	SSR() antlr.TerminalNode
	SYSEIB() antlr.TerminalNode
	TERMINAL() antlr.TerminalNode
	TERM() antlr.TerminalNode
	TEST() antlr.TerminalNode
	HOOK() antlr.TerminalNode
	NOHOOK() antlr.TerminalNode
	SEP() antlr.TerminalNode
	SEPARATE() antlr.TerminalNode
	NOSEP() antlr.TerminalNode
	NOSEPARATE() antlr.TerminalNode
	EJPD() antlr.TerminalNode
	NOEJPD() antlr.TerminalNode
	THREAD() antlr.TerminalNode
	TRUNC() antlr.TerminalNode
	BIN() antlr.TerminalNode
	VBREF() antlr.TerminalNode
	WORD() antlr.TerminalNode
	WD() antlr.TerminalNode
	XMLPARSE() antlr.TerminalNode
	XP() antlr.TerminalNode
	XMLSS() antlr.TerminalNode
	X_CHAR() antlr.TerminalNode
	XREF() antlr.TerminalNode
	SHORT() antlr.TerminalNode
	YEARWINDOW() antlr.TerminalNode
	YW() antlr.TerminalNode
	ZWB() antlr.TerminalNode

	// IsCompilerOptionContext differentiates from other interfaces.
	IsCompilerOptionContext()
}

type CompilerOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilerOptionContext() *CompilerOptionContext {
	var p = new(CompilerOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerOption
	return p
}

func InitEmptyCompilerOptionContext(p *CompilerOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerOption
}

func (*CompilerOptionContext) IsCompilerOptionContext() {}

func NewCompilerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilerOptionContext {
	var p = new(CompilerOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_compilerOption

	return p
}

func (s *CompilerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilerOptionContext) ADATA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserADATA, 0)
}

func (s *CompilerOptionContext) ADV() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserADV, 0)
}

func (s *CompilerOptionContext) APOST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserAPOST, 0)
}

func (s *CompilerOptionContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLPARENCHAR, 0)
}

func (s *CompilerOptionContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserRPARENCHAR, 0)
}

func (s *CompilerOptionContext) ARITH() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserARITH, 0)
}

func (s *CompilerOptionContext) AR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserAR, 0)
}

func (s *CompilerOptionContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXTEND, 0)
}

func (s *CompilerOptionContext) AllE_CHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserE_CHAR)
}

func (s *CompilerOptionContext) E_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserE_CHAR, i)
}

func (s *CompilerOptionContext) COMPAT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOMPAT, 0)
}

func (s *CompilerOptionContext) C_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserC_CHAR, 0)
}

func (s *CompilerOptionContext) AWO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserAWO, 0)
}

func (s *CompilerOptionContext) BLOCK0() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBLOCK0, 0)
}

func (s *CompilerOptionContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *CompilerOptionContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CompilerOptionContext) BUFSIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBUFSIZE, 0)
}

func (s *CompilerOptionContext) BUF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBUF, 0)
}

func (s *CompilerOptionContext) CBLCARD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCBLCARD, 0)
}

func (s *CompilerOptionContext) CICS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCICS, 0)
}

func (s *CompilerOptionContext) COBOL2() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOBOL2, 0)
}

func (s *CompilerOptionContext) COBOL3() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOBOL3, 0)
}

func (s *CompilerOptionContext) CODEPAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCODEPAGE, 0)
}

func (s *CompilerOptionContext) CP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCP, 0)
}

func (s *CompilerOptionContext) COMPILE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOMPILE, 0)
}

func (s *CompilerOptionContext) CPP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCPP, 0)
}

func (s *CompilerOptionContext) CPSM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCPSM, 0)
}

func (s *CompilerOptionContext) CURRENCY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCURRENCY, 0)
}

func (s *CompilerOptionContext) CURR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCURR, 0)
}

func (s *CompilerOptionContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDATA, 0)
}

func (s *CompilerOptionContext) DATEPROC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDATEPROC, 0)
}

func (s *CompilerOptionContext) DP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDP, 0)
}

func (s *CompilerOptionContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserCOMMACHAR)
}

func (s *CompilerOptionContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOMMACHAR, i)
}

func (s *CompilerOptionContext) FLAG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFLAG, 0)
}

func (s *CompilerOptionContext) NOFLAG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFLAG, 0)
}

func (s *CompilerOptionContext) TRIG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTRIG, 0)
}

func (s *CompilerOptionContext) NOTRIG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTRIG, 0)
}

func (s *CompilerOptionContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDBCS, 0)
}

func (s *CompilerOptionContext) DECK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDECK, 0)
}

func (s *CompilerOptionContext) D_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserD_CHAR, 0)
}

func (s *CompilerOptionContext) DEBUG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDEBUG, 0)
}

func (s *CompilerOptionContext) DIAGTRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDIAGTRUNC, 0)
}

func (s *CompilerOptionContext) DTR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDTR, 0)
}

func (s *CompilerOptionContext) DLL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDLL, 0)
}

func (s *CompilerOptionContext) DUMP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDUMP, 0)
}

func (s *CompilerOptionContext) DU() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDU, 0)
}

func (s *CompilerOptionContext) DYNAM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDYNAM, 0)
}

func (s *CompilerOptionContext) DYN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDYN, 0)
}

func (s *CompilerOptionContext) EDF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEDF, 0)
}

func (s *CompilerOptionContext) EPILOG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEPILOG, 0)
}

func (s *CompilerOptionContext) EXIT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXIT, 0)
}

func (s *CompilerOptionContext) EXPORTALL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXPORTALL, 0)
}

func (s *CompilerOptionContext) EXP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXP, 0)
}

func (s *CompilerOptionContext) FASTSRT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFASTSRT, 0)
}

func (s *CompilerOptionContext) FSRT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFSRT, 0)
}

func (s *CompilerOptionContext) FEPI() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFEPI, 0)
}

func (s *CompilerOptionContext) F_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserF_CHAR, 0)
}

func (s *CompilerOptionContext) AllI_CHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserI_CHAR)
}

func (s *CompilerOptionContext) I_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserI_CHAR, i)
}

func (s *CompilerOptionContext) AllS_CHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserS_CHAR)
}

func (s *CompilerOptionContext) S_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserS_CHAR, i)
}

func (s *CompilerOptionContext) AllU_CHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserU_CHAR)
}

func (s *CompilerOptionContext) U_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserU_CHAR, i)
}

func (s *CompilerOptionContext) AllW_CHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserW_CHAR)
}

func (s *CompilerOptionContext) W_CHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserW_CHAR, i)
}

func (s *CompilerOptionContext) FLAGSTD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFLAGSTD, 0)
}

func (s *CompilerOptionContext) M_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserM_CHAR, 0)
}

func (s *CompilerOptionContext) H_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserH_CHAR, 0)
}

func (s *CompilerOptionContext) DD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDD, 0)
}

func (s *CompilerOptionContext) N_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserN_CHAR, 0)
}

func (s *CompilerOptionContext) NN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNN, 0)
}

func (s *CompilerOptionContext) SS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSS, 0)
}

func (s *CompilerOptionContext) GDS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserGDS, 0)
}

func (s *CompilerOptionContext) GRAPHIC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserGRAPHIC, 0)
}

func (s *CompilerOptionContext) INTDATE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserINTDATE, 0)
}

func (s *CompilerOptionContext) ANSI() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserANSI, 0)
}

func (s *CompilerOptionContext) LILIAN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLILIAN, 0)
}

func (s *CompilerOptionContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLANGUAGE, 0)
}

func (s *CompilerOptionContext) LANG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLANG, 0)
}

func (s *CompilerOptionContext) ENGLISH() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserENGLISH, 0)
}

func (s *CompilerOptionContext) CS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCS, 0)
}

func (s *CompilerOptionContext) EN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEN, 0)
}

func (s *CompilerOptionContext) JA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserJA, 0)
}

func (s *CompilerOptionContext) JP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserJP, 0)
}

func (s *CompilerOptionContext) KA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserKA, 0)
}

func (s *CompilerOptionContext) UE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserUE, 0)
}

func (s *CompilerOptionContext) LEASM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLEASM, 0)
}

func (s *CompilerOptionContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLENGTH, 0)
}

func (s *CompilerOptionContext) LIB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLIB, 0)
}

func (s *CompilerOptionContext) LIN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLIN, 0)
}

func (s *CompilerOptionContext) LINECOUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLINECOUNT, 0)
}

func (s *CompilerOptionContext) LC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLC, 0)
}

func (s *CompilerOptionContext) LINKAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLINKAGE, 0)
}

func (s *CompilerOptionContext) LIST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLIST, 0)
}

func (s *CompilerOptionContext) MAP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMAP, 0)
}

func (s *CompilerOptionContext) MARGINS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMARGINS, 0)
}

func (s *CompilerOptionContext) MDECK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMDECK, 0)
}

func (s *CompilerOptionContext) MD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMD, 0)
}

func (s *CompilerOptionContext) NOC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOC, 0)
}

func (s *CompilerOptionContext) NOCOMPILE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCOMPILE, 0)
}

func (s *CompilerOptionContext) NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNAME, 0)
}

func (s *CompilerOptionContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserALIAS, 0)
}

func (s *CompilerOptionContext) NOALIAS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOALIAS, 0)
}

func (s *CompilerOptionContext) NATLANG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNATLANG, 0)
}

func (s *CompilerOptionContext) NOADATA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOADATA, 0)
}

func (s *CompilerOptionContext) NOADV() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOADV, 0)
}

func (s *CompilerOptionContext) NOAWO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOAWO, 0)
}

func (s *CompilerOptionContext) NOBLOCK0() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOBLOCK0, 0)
}

func (s *CompilerOptionContext) NOCBLCARD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCBLCARD, 0)
}

func (s *CompilerOptionContext) NOCICS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCICS, 0)
}

func (s *CompilerOptionContext) NOCMPR2() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCMPR2, 0)
}

func (s *CompilerOptionContext) NOCPSM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCPSM, 0)
}

func (s *CompilerOptionContext) NOCURRENCY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCURRENCY, 0)
}

func (s *CompilerOptionContext) NOCURR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCURR, 0)
}

func (s *CompilerOptionContext) NODATEPROC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODATEPROC, 0)
}

func (s *CompilerOptionContext) NODP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODP, 0)
}

func (s *CompilerOptionContext) NODBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODBCS, 0)
}

func (s *CompilerOptionContext) NODEBUG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODEBUG, 0)
}

func (s *CompilerOptionContext) NODECK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODECK, 0)
}

func (s *CompilerOptionContext) NOD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOD, 0)
}

func (s *CompilerOptionContext) NODLL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODLL, 0)
}

func (s *CompilerOptionContext) NODE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODE, 0)
}

func (s *CompilerOptionContext) NODUMP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODUMP, 0)
}

func (s *CompilerOptionContext) NODU() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODU, 0)
}

func (s *CompilerOptionContext) NODIAGTRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODIAGTRUNC, 0)
}

func (s *CompilerOptionContext) NODTR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODTR, 0)
}

func (s *CompilerOptionContext) NODYNAM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODYNAM, 0)
}

func (s *CompilerOptionContext) NODYN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODYN, 0)
}

func (s *CompilerOptionContext) NOEDF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEDF, 0)
}

func (s *CompilerOptionContext) NOEPILOG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEPILOG, 0)
}

func (s *CompilerOptionContext) NOEXIT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEXIT, 0)
}

func (s *CompilerOptionContext) NOEXPORTALL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEXPORTALL, 0)
}

func (s *CompilerOptionContext) NOEXP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEXP, 0)
}

func (s *CompilerOptionContext) NOFASTSRT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFASTSRT, 0)
}

func (s *CompilerOptionContext) NOFSRT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFSRT, 0)
}

func (s *CompilerOptionContext) NOFEPI() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFEPI, 0)
}

func (s *CompilerOptionContext) NOF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOF, 0)
}

func (s *CompilerOptionContext) NOFLAGMIG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFLAGMIG, 0)
}

func (s *CompilerOptionContext) NOFLAGSTD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFLAGSTD, 0)
}

func (s *CompilerOptionContext) NOGRAPHIC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOGRAPHIC, 0)
}

func (s *CompilerOptionContext) NOLENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOLENGTH, 0)
}

func (s *CompilerOptionContext) NOLIB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOLIB, 0)
}

func (s *CompilerOptionContext) NOLINKAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOLINKAGE, 0)
}

func (s *CompilerOptionContext) NOLIST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOLIST, 0)
}

func (s *CompilerOptionContext) NOMAP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOMAP, 0)
}

func (s *CompilerOptionContext) NOMDECK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOMDECK, 0)
}

func (s *CompilerOptionContext) NOMD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOMD, 0)
}

func (s *CompilerOptionContext) NONAME() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNONAME, 0)
}

func (s *CompilerOptionContext) NONUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNONUMBER, 0)
}

func (s *CompilerOptionContext) NONUM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNONUM, 0)
}

func (s *CompilerOptionContext) NOOBJECT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOBJECT, 0)
}

func (s *CompilerOptionContext) NOOBJ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOBJ, 0)
}

func (s *CompilerOptionContext) NOOFFSET() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOFFSET, 0)
}

func (s *CompilerOptionContext) NOOFF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOFF, 0)
}

func (s *CompilerOptionContext) NOOPSEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOPSEQUENCE, 0)
}

func (s *CompilerOptionContext) NOOPTIMIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOPTIMIZE, 0)
}

func (s *CompilerOptionContext) NOOPT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOPT, 0)
}

func (s *CompilerOptionContext) NOOPTIONS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOPTIONS, 0)
}

func (s *CompilerOptionContext) NOP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOP, 0)
}

func (s *CompilerOptionContext) NOPROLOG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOPROLOG, 0)
}

func (s *CompilerOptionContext) NORENT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNORENT, 0)
}

func (s *CompilerOptionContext) NOSEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSEQUENCE, 0)
}

func (s *CompilerOptionContext) NOSEQ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSEQ, 0)
}

func (s *CompilerOptionContext) NOSOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSOURCE, 0)
}

func (s *CompilerOptionContext) NOS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOS, 0)
}

func (s *CompilerOptionContext) NOSPIE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSPIE, 0)
}

func (s *CompilerOptionContext) NOSQL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSQL, 0)
}

func (s *CompilerOptionContext) NOSQLCCSID() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSQLCCSID, 0)
}

func (s *CompilerOptionContext) NOSQLC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSQLC, 0)
}

func (s *CompilerOptionContext) NOSSRANGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSSRANGE, 0)
}

func (s *CompilerOptionContext) NOSSR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSSR, 0)
}

func (s *CompilerOptionContext) NOSTDTRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSTDTRUNC, 0)
}

func (s *CompilerOptionContext) NOTERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTERMINAL, 0)
}

func (s *CompilerOptionContext) NOTERM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTERM, 0)
}

func (s *CompilerOptionContext) NOTEST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTEST, 0)
}

func (s *CompilerOptionContext) NOTHREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTHREAD, 0)
}

func (s *CompilerOptionContext) NOVBREF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOVBREF, 0)
}

func (s *CompilerOptionContext) NOWORD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOWORD, 0)
}

func (s *CompilerOptionContext) NOWD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOWD, 0)
}

func (s *CompilerOptionContext) NSEQ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNSEQ, 0)
}

func (s *CompilerOptionContext) NSYMBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNSYMBOL, 0)
}

func (s *CompilerOptionContext) NS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNS, 0)
}

func (s *CompilerOptionContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNATIONAL, 0)
}

func (s *CompilerOptionContext) NAT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNAT, 0)
}

func (s *CompilerOptionContext) NOXREF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOXREF, 0)
}

func (s *CompilerOptionContext) NOX() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOX, 0)
}

func (s *CompilerOptionContext) NOZWB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOZWB, 0)
}

func (s *CompilerOptionContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNUMBER, 0)
}

func (s *CompilerOptionContext) NUM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNUM, 0)
}

func (s *CompilerOptionContext) NUMPROC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNUMPROC, 0)
}

func (s *CompilerOptionContext) MIG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMIG, 0)
}

func (s *CompilerOptionContext) NOPFD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOPFD, 0)
}

func (s *CompilerOptionContext) PFD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPFD, 0)
}

func (s *CompilerOptionContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOBJECT, 0)
}

func (s *CompilerOptionContext) OBJ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOBJ, 0)
}

func (s *CompilerOptionContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOFFSET, 0)
}

func (s *CompilerOptionContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOFF, 0)
}

func (s *CompilerOptionContext) OPMARGINS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPMARGINS, 0)
}

func (s *CompilerOptionContext) OPSEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPSEQUENCE, 0)
}

func (s *CompilerOptionContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPTIMIZE, 0)
}

func (s *CompilerOptionContext) OPT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPT, 0)
}

func (s *CompilerOptionContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFULL, 0)
}

func (s *CompilerOptionContext) STD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSTD, 0)
}

func (s *CompilerOptionContext) OPTFILE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPTFILE, 0)
}

func (s *CompilerOptionContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPTIONS, 0)
}

func (s *CompilerOptionContext) OP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOP, 0)
}

func (s *CompilerOptionContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CompilerOptionContext) OUTDD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOUTDD, 0)
}

func (s *CompilerOptionContext) OUT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOUT, 0)
}

func (s *CompilerOptionContext) PGMNAME() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPGMNAME, 0)
}

func (s *CompilerOptionContext) PGMN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPGMN, 0)
}

func (s *CompilerOptionContext) CO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCO, 0)
}

func (s *CompilerOptionContext) LM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLM, 0)
}

func (s *CompilerOptionContext) LONGMIXED() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLONGMIXED, 0)
}

func (s *CompilerOptionContext) LONGUPPER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLONGUPPER, 0)
}

func (s *CompilerOptionContext) LU() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLU, 0)
}

func (s *CompilerOptionContext) MIXED() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMIXED, 0)
}

func (s *CompilerOptionContext) UPPER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserUPPER, 0)
}

func (s *CompilerOptionContext) PROLOG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPROLOG, 0)
}

func (s *CompilerOptionContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserQUOTE, 0)
}

func (s *CompilerOptionContext) Q_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserQ_CHAR, 0)
}

func (s *CompilerOptionContext) RENT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserRENT, 0)
}

func (s *CompilerOptionContext) RMODE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserRMODE, 0)
}

func (s *CompilerOptionContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserANY, 0)
}

func (s *CompilerOptionContext) AUTO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserAUTO, 0)
}

func (s *CompilerOptionContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSEQUENCE, 0)
}

func (s *CompilerOptionContext) SEQ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSEQ, 0)
}

func (s *CompilerOptionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSIZE, 0)
}

func (s *CompilerOptionContext) SZ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSZ, 0)
}

func (s *CompilerOptionContext) MAX() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMAX, 0)
}

func (s *CompilerOptionContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSOURCE, 0)
}

func (s *CompilerOptionContext) SP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSP, 0)
}

func (s *CompilerOptionContext) SPACE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSPACE, 0)
}

func (s *CompilerOptionContext) SPIE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSPIE, 0)
}

func (s *CompilerOptionContext) SQL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSQL, 0)
}

func (s *CompilerOptionContext) SQLCCSID() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSQLCCSID, 0)
}

func (s *CompilerOptionContext) SQLC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSQLC, 0)
}

func (s *CompilerOptionContext) SSRANGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSSRANGE, 0)
}

func (s *CompilerOptionContext) SSR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSSR, 0)
}

func (s *CompilerOptionContext) SYSEIB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSYSEIB, 0)
}

func (s *CompilerOptionContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTERMINAL, 0)
}

func (s *CompilerOptionContext) TERM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTERM, 0)
}

func (s *CompilerOptionContext) TEST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTEST, 0)
}

func (s *CompilerOptionContext) HOOK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserHOOK, 0)
}

func (s *CompilerOptionContext) NOHOOK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOHOOK, 0)
}

func (s *CompilerOptionContext) SEP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSEP, 0)
}

func (s *CompilerOptionContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSEPARATE, 0)
}

func (s *CompilerOptionContext) NOSEP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSEP, 0)
}

func (s *CompilerOptionContext) NOSEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSEPARATE, 0)
}

func (s *CompilerOptionContext) EJPD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEJPD, 0)
}

func (s *CompilerOptionContext) NOEJPD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEJPD, 0)
}

func (s *CompilerOptionContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTHREAD, 0)
}

func (s *CompilerOptionContext) TRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTRUNC, 0)
}

func (s *CompilerOptionContext) BIN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBIN, 0)
}

func (s *CompilerOptionContext) VBREF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserVBREF, 0)
}

func (s *CompilerOptionContext) WORD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserWORD, 0)
}

func (s *CompilerOptionContext) WD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserWD, 0)
}

func (s *CompilerOptionContext) XMLPARSE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXMLPARSE, 0)
}

func (s *CompilerOptionContext) XP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXP, 0)
}

func (s *CompilerOptionContext) XMLSS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXMLSS, 0)
}

func (s *CompilerOptionContext) X_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserX_CHAR, 0)
}

func (s *CompilerOptionContext) XREF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXREF, 0)
}

func (s *CompilerOptionContext) SHORT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSHORT, 0)
}

func (s *CompilerOptionContext) YEARWINDOW() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserYEARWINDOW, 0)
}

func (s *CompilerOptionContext) YW() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserYW, 0)
}

func (s *CompilerOptionContext) ZWB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserZWB, 0)
}

func (s *CompilerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCompilerOption(s)
	}
}

func (s *CompilerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCompilerOption(s)
	}
}

func (s *CompilerOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCompilerOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CompilerOption() (localctx ICompilerOptionContext) {
	localctx = NewCompilerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Cobol85PreprocessorParserRULE_compilerOption)
	var _la int

	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(107)
			p.Match(Cobol85PreprocessorParserADATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(108)
			p.Match(Cobol85PreprocessorParserADV)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(109)
			p.Match(Cobol85PreprocessorParserAPOST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(110)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserAR || _la == Cobol85PreprocessorParserARITH) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(111)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(112)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserCOMPAT || _la == Cobol85PreprocessorParserEXTEND || _la == Cobol85PreprocessorParserC_CHAR || _la == Cobol85PreprocessorParserE_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(113)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(114)
			p.Match(Cobol85PreprocessorParserAWO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(115)
			p.Match(Cobol85PreprocessorParserBLOCK0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(116)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserBUF || _la == Cobol85PreprocessorParserBUFSIZE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(117)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(118)
			p.Literal()
		}
		{
			p.SetState(119)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(121)
			p.Match(Cobol85PreprocessorParserCBLCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(122)
			p.Match(Cobol85PreprocessorParserCICS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(127)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(123)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(124)
				p.Literal()
			}
			{
				p.SetState(125)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(129)
			p.Match(Cobol85PreprocessorParserCOBOL2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(130)
			p.Match(Cobol85PreprocessorParserCOBOL3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(131)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserCODEPAGE || _la == Cobol85PreprocessorParserCP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(132)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(133)
			p.Literal()
		}
		{
			p.SetState(134)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(136)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserCOMPILE || _la == Cobol85PreprocessorParserC_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(137)
			p.Match(Cobol85PreprocessorParserCPP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(138)
			p.Match(Cobol85PreprocessorParserCPSM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(139)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserCURR || _la == Cobol85PreprocessorParserCURRENCY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(140)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(141)
			p.Literal()
		}
		{
			p.SetState(142)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(144)
			p.Match(Cobol85PreprocessorParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(145)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(146)
			p.Literal()
		}
		{
			p.SetState(147)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(149)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserDATEPROC || _la == Cobol85PreprocessorParserDP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(161)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(150)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(152)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85PreprocessorParserFLAG || _la == Cobol85PreprocessorParserNOFLAG {
				{
					p.SetState(151)
					_la = p.GetTokenStream().LA(1)

					if !(_la == Cobol85PreprocessorParserFLAG || _la == Cobol85PreprocessorParserNOFLAG) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(155)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85PreprocessorParserCOMMACHAR {
				{
					p.SetState(154)
					p.Match(Cobol85PreprocessorParserCOMMACHAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(158)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85PreprocessorParserNOTRIG || _la == Cobol85PreprocessorParserTRIG {
				{
					p.SetState(157)
					_la = p.GetTokenStream().LA(1)

					if !(_la == Cobol85PreprocessorParserNOTRIG || _la == Cobol85PreprocessorParserTRIG) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(160)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(163)
			p.Match(Cobol85PreprocessorParserDBCS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(164)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserDECK || _la == Cobol85PreprocessorParserD_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(165)
			p.Match(Cobol85PreprocessorParserDEBUG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(166)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserDIAGTRUNC || _la == Cobol85PreprocessorParserDTR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(167)
			p.Match(Cobol85PreprocessorParserDLL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(168)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserDU || _la == Cobol85PreprocessorParserDUMP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(169)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserDYN || _la == Cobol85PreprocessorParserDYNAM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(170)
			p.Match(Cobol85PreprocessorParserEDF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(171)
			p.Match(Cobol85PreprocessorParserEPILOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(172)
			p.Match(Cobol85PreprocessorParserEXIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(173)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserEXP || _la == Cobol85PreprocessorParserEXPORTALL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(174)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserFASTSRT || _la == Cobol85PreprocessorParserFSRT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(175)
			p.Match(Cobol85PreprocessorParserFEPI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(176)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserFLAG || _la == Cobol85PreprocessorParserF_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(177)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(178)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-271)) & ^0x3f) == 0 && ((int64(1)<<(_la-271))&905) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85PreprocessorParserCOMMACHAR {
			{
				p.SetState(179)
				p.Match(Cobol85PreprocessorParserCOMMACHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(180)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-271)) & ^0x3f) == 0 && ((int64(1)<<(_la-271))&905) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(183)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(184)
			p.Match(Cobol85PreprocessorParserFLAGSTD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(185)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(186)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-273)) & ^0x3f) == 0 && ((int64(1)<<(_la-273))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85PreprocessorParserCOMMACHAR {
			{
				p.SetState(187)
				p.Match(Cobol85PreprocessorParserCOMMACHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(188)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Cobol85PreprocessorParserDD || _la == Cobol85PreprocessorParserNN || ((int64((_la-242)) & ^0x3f) == 0 && ((int64(1)<<(_la-242))&86167781377) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(191)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(192)
			p.Match(Cobol85PreprocessorParserGDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(193)
			p.Match(Cobol85PreprocessorParserGRAPHIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(194)
			p.Match(Cobol85PreprocessorParserINTDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(195)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserANSI || _la == Cobol85PreprocessorParserLILIAN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(197)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(198)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserLANG || _la == Cobol85PreprocessorParserLANGUAGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(199)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(200)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-29)) & ^0x3f) == 0 && ((int64(1)<<(_la-29))&30786331869185) != 0) || _la == Cobol85PreprocessorParserUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(201)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(202)
			p.Match(Cobol85PreprocessorParserLEASM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(203)
			p.Match(Cobol85PreprocessorParserLENGTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(204)
			p.Match(Cobol85PreprocessorParserLIB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(205)
			p.Match(Cobol85PreprocessorParserLIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(206)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserLC || _la == Cobol85PreprocessorParserLINECOUNT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(207)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(208)
			p.Literal()
		}
		{
			p.SetState(209)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(211)
			p.Match(Cobol85PreprocessorParserLINKAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(212)
			p.Match(Cobol85PreprocessorParserLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(213)
			p.Match(Cobol85PreprocessorParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(214)
			p.Match(Cobol85PreprocessorParserMARGINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(215)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(216)
			p.Literal()
		}
		{
			p.SetState(217)
			p.Match(Cobol85PreprocessorParserCOMMACHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(218)
			p.Literal()
		}
		p.SetState(221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85PreprocessorParserCOMMACHAR {
			{
				p.SetState(219)
				p.Match(Cobol85PreprocessorParserCOMMACHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(220)
				p.Literal()
			}

		}
		{
			p.SetState(223)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(225)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserMD || _la == Cobol85PreprocessorParserMDECK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(229)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(226)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(227)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Cobol85PreprocessorParserCOMPILE || _la == Cobol85PreprocessorParserNOC || _la == Cobol85PreprocessorParserNOCOMPILE || _la == Cobol85PreprocessorParserC_CHAR) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(228)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(231)
			p.Match(Cobol85PreprocessorParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(235)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(232)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(233)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Cobol85PreprocessorParserALIAS || _la == Cobol85PreprocessorParserNOALIAS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(234)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(237)
			p.Match(Cobol85PreprocessorParserNATLANG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(238)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(239)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-29)) & ^0x3f) == 0 && ((int64(1)<<(_la-29))&17592188141569) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(240)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(241)
			p.Match(Cobol85PreprocessorParserNOADATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(242)
			p.Match(Cobol85PreprocessorParserNOADV)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(243)
			p.Match(Cobol85PreprocessorParserNOAWO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(244)
			p.Match(Cobol85PreprocessorParserNOBLOCK0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(245)
			p.Match(Cobol85PreprocessorParserNOCBLCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(246)
			p.Match(Cobol85PreprocessorParserNOCICS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(247)
			p.Match(Cobol85PreprocessorParserNOCMPR2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(248)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOC || _la == Cobol85PreprocessorParserNOCOMPILE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(252)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(249)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(250)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-271)) & ^0x3f) == 0 && ((int64(1)<<(_la-271))&641) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(251)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(254)
			p.Match(Cobol85PreprocessorParserNOCPSM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(255)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOCURR || _la == Cobol85PreprocessorParserNOCURRENCY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(256)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNODATEPROC || _la == Cobol85PreprocessorParserNODP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(257)
			p.Match(Cobol85PreprocessorParserNODBCS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(258)
			p.Match(Cobol85PreprocessorParserNODEBUG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(259)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOD || _la == Cobol85PreprocessorParserNODECK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(260)
			p.Match(Cobol85PreprocessorParserNODLL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(261)
			p.Match(Cobol85PreprocessorParserNODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(262)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNODU || _la == Cobol85PreprocessorParserNODUMP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 67:
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(263)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNODIAGTRUNC || _la == Cobol85PreprocessorParserNODTR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 68:
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(264)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNODYN || _la == Cobol85PreprocessorParserNODYNAM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 69:
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(265)
			p.Match(Cobol85PreprocessorParserNOEDF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 70:
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(266)
			p.Match(Cobol85PreprocessorParserNOEPILOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 71:
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(267)
			p.Match(Cobol85PreprocessorParserNOEXIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 72:
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(268)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOEXP || _la == Cobol85PreprocessorParserNOEXPORTALL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 73:
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(269)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOFASTSRT || _la == Cobol85PreprocessorParserNOFSRT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 74:
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(270)
			p.Match(Cobol85PreprocessorParserNOFEPI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 75:
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(271)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOF || _la == Cobol85PreprocessorParserNOFLAG) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 76:
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(272)
			p.Match(Cobol85PreprocessorParserNOFLAGMIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 77:
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(273)
			p.Match(Cobol85PreprocessorParserNOFLAGSTD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 78:
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(274)
			p.Match(Cobol85PreprocessorParserNOGRAPHIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 79:
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(275)
			p.Match(Cobol85PreprocessorParserNOLENGTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 80:
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(276)
			p.Match(Cobol85PreprocessorParserNOLIB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 81:
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(277)
			p.Match(Cobol85PreprocessorParserNOLINKAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 82:
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(278)
			p.Match(Cobol85PreprocessorParserNOLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 83:
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(279)
			p.Match(Cobol85PreprocessorParserNOMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 84:
		p.EnterOuterAlt(localctx, 84)
		{
			p.SetState(280)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOMD || _la == Cobol85PreprocessorParserNOMDECK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 85:
		p.EnterOuterAlt(localctx, 85)
		{
			p.SetState(281)
			p.Match(Cobol85PreprocessorParserNONAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 86:
		p.EnterOuterAlt(localctx, 86)
		{
			p.SetState(282)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNONUM || _la == Cobol85PreprocessorParserNONUMBER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 87:
		p.EnterOuterAlt(localctx, 87)
		{
			p.SetState(283)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOOBJ || _la == Cobol85PreprocessorParserNOOBJECT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 88:
		p.EnterOuterAlt(localctx, 88)
		{
			p.SetState(284)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOOFF || _la == Cobol85PreprocessorParserNOOFFSET) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 89:
		p.EnterOuterAlt(localctx, 89)
		{
			p.SetState(285)
			p.Match(Cobol85PreprocessorParserNOOPSEQUENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 90:
		p.EnterOuterAlt(localctx, 90)
		{
			p.SetState(286)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOOPT || _la == Cobol85PreprocessorParserNOOPTIMIZE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 91:
		p.EnterOuterAlt(localctx, 91)
		{
			p.SetState(287)
			p.Match(Cobol85PreprocessorParserNOOPTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 92:
		p.EnterOuterAlt(localctx, 92)
		{
			p.SetState(288)
			p.Match(Cobol85PreprocessorParserNOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 93:
		p.EnterOuterAlt(localctx, 93)
		{
			p.SetState(289)
			p.Match(Cobol85PreprocessorParserNOPROLOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 94:
		p.EnterOuterAlt(localctx, 94)
		{
			p.SetState(290)
			p.Match(Cobol85PreprocessorParserNORENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 95:
		p.EnterOuterAlt(localctx, 95)
		{
			p.SetState(291)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOSEQ || _la == Cobol85PreprocessorParserNOSEQUENCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 96:
		p.EnterOuterAlt(localctx, 96)
		{
			p.SetState(292)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOS || _la == Cobol85PreprocessorParserNOSOURCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 97:
		p.EnterOuterAlt(localctx, 97)
		{
			p.SetState(293)
			p.Match(Cobol85PreprocessorParserNOSPIE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 98:
		p.EnterOuterAlt(localctx, 98)
		{
			p.SetState(294)
			p.Match(Cobol85PreprocessorParserNOSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 99:
		p.EnterOuterAlt(localctx, 99)
		{
			p.SetState(295)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOSQLC || _la == Cobol85PreprocessorParserNOSQLCCSID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 100:
		p.EnterOuterAlt(localctx, 100)
		{
			p.SetState(296)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOSSR || _la == Cobol85PreprocessorParserNOSSRANGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 101:
		p.EnterOuterAlt(localctx, 101)
		{
			p.SetState(297)
			p.Match(Cobol85PreprocessorParserNOSTDTRUNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 102:
		p.EnterOuterAlt(localctx, 102)
		{
			p.SetState(298)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOTERM || _la == Cobol85PreprocessorParserNOTERMINAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 103:
		p.EnterOuterAlt(localctx, 103)
		{
			p.SetState(299)
			p.Match(Cobol85PreprocessorParserNOTEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 104:
		p.EnterOuterAlt(localctx, 104)
		{
			p.SetState(300)
			p.Match(Cobol85PreprocessorParserNOTHREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 105:
		p.EnterOuterAlt(localctx, 105)
		{
			p.SetState(301)
			p.Match(Cobol85PreprocessorParserNOVBREF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 106:
		p.EnterOuterAlt(localctx, 106)
		{
			p.SetState(302)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOWD || _la == Cobol85PreprocessorParserNOWORD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 107:
		p.EnterOuterAlt(localctx, 107)
		{
			p.SetState(303)
			p.Match(Cobol85PreprocessorParserNSEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 108:
		p.EnterOuterAlt(localctx, 108)
		{
			p.SetState(304)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNS || _la == Cobol85PreprocessorParserNSYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(305)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(306)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserDBCS || _la == Cobol85PreprocessorParserNAT || _la == Cobol85PreprocessorParserNATIONAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(307)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 109:
		p.EnterOuterAlt(localctx, 109)
		{
			p.SetState(308)
			p.Match(Cobol85PreprocessorParserNOVBREF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 110:
		p.EnterOuterAlt(localctx, 110)
		{
			p.SetState(309)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNOX || _la == Cobol85PreprocessorParserNOXREF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 111:
		p.EnterOuterAlt(localctx, 111)
		{
			p.SetState(310)
			p.Match(Cobol85PreprocessorParserNOZWB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 112:
		p.EnterOuterAlt(localctx, 112)
		{
			p.SetState(311)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserNUM || _la == Cobol85PreprocessorParserNUMBER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 113:
		p.EnterOuterAlt(localctx, 113)
		{
			p.SetState(312)
			p.Match(Cobol85PreprocessorParserNUMPROC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(313)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(314)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserMIG || _la == Cobol85PreprocessorParserNOPFD || _la == Cobol85PreprocessorParserPFD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(315)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 114:
		p.EnterOuterAlt(localctx, 114)
		{
			p.SetState(316)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserOBJ || _la == Cobol85PreprocessorParserOBJECT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 115:
		p.EnterOuterAlt(localctx, 115)
		{
			p.SetState(317)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserOFF || _la == Cobol85PreprocessorParserOFFSET) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 116:
		p.EnterOuterAlt(localctx, 116)
		{
			p.SetState(318)
			p.Match(Cobol85PreprocessorParserOPMARGINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(319)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(320)
			p.Literal()
		}
		{
			p.SetState(321)
			p.Match(Cobol85PreprocessorParserCOMMACHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(322)
			p.Literal()
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85PreprocessorParserCOMMACHAR {
			{
				p.SetState(323)
				p.Match(Cobol85PreprocessorParserCOMMACHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(324)
				p.Literal()
			}

		}
		{
			p.SetState(327)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 117:
		p.EnterOuterAlt(localctx, 117)
		{
			p.SetState(329)
			p.Match(Cobol85PreprocessorParserOPSEQUENCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(330)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(331)
			p.Literal()
		}
		{
			p.SetState(332)
			p.Match(Cobol85PreprocessorParserCOMMACHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(333)
			p.Literal()
		}
		{
			p.SetState(334)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 118:
		p.EnterOuterAlt(localctx, 118)
		{
			p.SetState(336)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserOPT || _la == Cobol85PreprocessorParserOPTIMIZE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(340)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(337)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(338)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Cobol85PreprocessorParserFULL || _la == Cobol85PreprocessorParserSTD) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(339)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 119:
		p.EnterOuterAlt(localctx, 119)
		{
			p.SetState(342)
			p.Match(Cobol85PreprocessorParserOPTFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 120:
		p.EnterOuterAlt(localctx, 120)
		{
			p.SetState(343)
			p.Match(Cobol85PreprocessorParserOPTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 121:
		p.EnterOuterAlt(localctx, 121)
		{
			p.SetState(344)
			p.Match(Cobol85PreprocessorParserOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 122:
		p.EnterOuterAlt(localctx, 122)
		{
			p.SetState(345)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserOUT || _la == Cobol85PreprocessorParserOUTDD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(346)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(347)
			p.CobolWord()
		}
		{
			p.SetState(348)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 123:
		p.EnterOuterAlt(localctx, 123)
		{
			p.SetState(350)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserPGMN || _la == Cobol85PreprocessorParserPGMNAME) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(351)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(352)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserCO || _la == Cobol85PreprocessorParserCOMPAT || ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&2071) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4456449) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(353)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 124:
		p.EnterOuterAlt(localctx, 124)
		{
			p.SetState(354)
			p.Match(Cobol85PreprocessorParserPROLOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 125:
		p.EnterOuterAlt(localctx, 125)
		{
			p.SetState(355)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserQUOTE || _la == Cobol85PreprocessorParserQ_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 126:
		p.EnterOuterAlt(localctx, 126)
		{
			p.SetState(356)
			p.Match(Cobol85PreprocessorParserRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 127:
		p.EnterOuterAlt(localctx, 127)
		{
			p.SetState(357)
			p.Match(Cobol85PreprocessorParserRMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(358)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cobol85PreprocessorParserANY:
			{
				p.SetState(359)
				p.Match(Cobol85PreprocessorParserANY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Cobol85PreprocessorParserAUTO:
			{
				p.SetState(360)
				p.Match(Cobol85PreprocessorParserAUTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL:
			{
				p.SetState(361)
				p.Literal()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(364)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 128:
		p.EnterOuterAlt(localctx, 128)
		{
			p.SetState(365)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserSEQ || _la == Cobol85PreprocessorParserSEQUENCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(372)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(366)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(367)
				p.Literal()
			}
			{
				p.SetState(368)
				p.Match(Cobol85PreprocessorParserCOMMACHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(369)
				p.Literal()
			}
			{
				p.SetState(370)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 129:
		p.EnterOuterAlt(localctx, 129)
		{
			p.SetState(374)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserSIZE || _la == Cobol85PreprocessorParserSZ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(375)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cobol85PreprocessorParserMAX:
			{
				p.SetState(376)
				p.Match(Cobol85PreprocessorParserMAX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL:
			{
				p.SetState(377)
				p.Literal()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(380)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 130:
		p.EnterOuterAlt(localctx, 130)
		{
			p.SetState(381)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserSOURCE || _la == Cobol85PreprocessorParserS_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 131:
		p.EnterOuterAlt(localctx, 131)
		{
			p.SetState(382)
			p.Match(Cobol85PreprocessorParserSP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 132:
		p.EnterOuterAlt(localctx, 132)
		{
			p.SetState(383)
			p.Match(Cobol85PreprocessorParserSPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(384)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(385)
			p.Literal()
		}
		{
			p.SetState(386)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 133:
		p.EnterOuterAlt(localctx, 133)
		{
			p.SetState(388)
			p.Match(Cobol85PreprocessorParserSPIE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 134:
		p.EnterOuterAlt(localctx, 134)
		{
			p.SetState(389)
			p.Match(Cobol85PreprocessorParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(394)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(390)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(391)
				p.Literal()
			}
			{
				p.SetState(392)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 135:
		p.EnterOuterAlt(localctx, 135)
		{
			p.SetState(396)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserSQLC || _la == Cobol85PreprocessorParserSQLCCSID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 136:
		p.EnterOuterAlt(localctx, 136)
		{
			p.SetState(397)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserSSR || _la == Cobol85PreprocessorParserSSRANGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 137:
		p.EnterOuterAlt(localctx, 137)
		{
			p.SetState(398)
			p.Match(Cobol85PreprocessorParserSYSEIB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 138:
		p.EnterOuterAlt(localctx, 138)
		{
			p.SetState(399)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserTERM || _la == Cobol85PreprocessorParserTERMINAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 139:
		p.EnterOuterAlt(localctx, 139)
		{
			p.SetState(400)
			p.Match(Cobol85PreprocessorParserTEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(418)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(401)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(403)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85PreprocessorParserHOOK || _la == Cobol85PreprocessorParserNOHOOK {
				{
					p.SetState(402)
					_la = p.GetTokenStream().LA(1)

					if !(_la == Cobol85PreprocessorParserHOOK || _la == Cobol85PreprocessorParserNOHOOK) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(406)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(405)
					p.Match(Cobol85PreprocessorParserCOMMACHAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(409)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-168)) & ^0x3f) == 0 && ((int64(1)<<(_la-168))&432345564227567619) != 0 {
				{
					p.SetState(408)
					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-168)) & ^0x3f) == 0 && ((int64(1)<<(_la-168))&432345564227567619) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			p.SetState(412)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85PreprocessorParserCOMMACHAR {
				{
					p.SetState(411)
					p.Match(Cobol85PreprocessorParserCOMMACHAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(415)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85PreprocessorParserEJPD || _la == Cobol85PreprocessorParserNOEJPD {
				{
					p.SetState(414)
					_la = p.GetTokenStream().LA(1)

					if !(_la == Cobol85PreprocessorParserEJPD || _la == Cobol85PreprocessorParserNOEJPD) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(417)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 140:
		p.EnterOuterAlt(localctx, 140)
		{
			p.SetState(420)
			p.Match(Cobol85PreprocessorParserTHREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 141:
		p.EnterOuterAlt(localctx, 141)
		{
			p.SetState(421)
			p.Match(Cobol85PreprocessorParserTRUNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(422)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(423)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserBIN || _la == Cobol85PreprocessorParserOPT || _la == Cobol85PreprocessorParserSTD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(424)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 142:
		p.EnterOuterAlt(localctx, 142)
		{
			p.SetState(425)
			p.Match(Cobol85PreprocessorParserVBREF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 143:
		p.EnterOuterAlt(localctx, 143)
		{
			p.SetState(426)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserWD || _la == Cobol85PreprocessorParserWORD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(427)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(428)
			p.CobolWord()
		}
		{
			p.SetState(429)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 144:
		p.EnterOuterAlt(localctx, 144)
		{
			p.SetState(431)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserXMLPARSE || _la == Cobol85PreprocessorParserXP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(432)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(433)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserCOMPAT || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&524417) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(434)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 145:
		p.EnterOuterAlt(localctx, 145)
		{
			p.SetState(435)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserXREF || _la == Cobol85PreprocessorParserX_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(436)
				p.Match(Cobol85PreprocessorParserLPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(438)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85PreprocessorParserFULL || _la == Cobol85PreprocessorParserSHORT {
				{
					p.SetState(437)
					_la = p.GetTokenStream().LA(1)

					if !(_la == Cobol85PreprocessorParserFULL || _la == Cobol85PreprocessorParserSHORT) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(440)
				p.Match(Cobol85PreprocessorParserRPARENCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 146:
		p.EnterOuterAlt(localctx, 146)
		{
			p.SetState(443)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserYEARWINDOW || _la == Cobol85PreprocessorParserYW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(444)
			p.Match(Cobol85PreprocessorParserLPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(445)
			p.Literal()
		}
		{
			p.SetState(446)
			p.Match(Cobol85PreprocessorParserRPARENCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 147:
		p.EnterOuterAlt(localctx, 147)
		{
			p.SetState(448)
			p.Match(Cobol85PreprocessorParserZWB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecCicsStatementContext is an interface to support dynamic dispatch.
type IExecCicsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXEC() antlr.TerminalNode
	CICS() antlr.TerminalNode
	CharData() ICharDataContext
	END_EXEC() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsExecCicsStatementContext differentiates from other interfaces.
	IsExecCicsStatementContext()
}

type ExecCicsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecCicsStatementContext() *ExecCicsStatementContext {
	var p = new(ExecCicsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_execCicsStatement
	return p
}

func InitEmptyExecCicsStatementContext(p *ExecCicsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_execCicsStatement
}

func (*ExecCicsStatementContext) IsExecCicsStatementContext() {}

func NewExecCicsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecCicsStatementContext {
	var p = new(ExecCicsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_execCicsStatement

	return p
}

func (s *ExecCicsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecCicsStatementContext) EXEC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXEC, 0)
}

func (s *ExecCicsStatementContext) CICS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCICS, 0)
}

func (s *ExecCicsStatementContext) CharData() ICharDataContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataContext)
}

func (s *ExecCicsStatementContext) END_EXEC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEND_EXEC, 0)
}

func (s *ExecCicsStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *ExecCicsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecCicsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecCicsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterExecCicsStatement(s)
	}
}

func (s *ExecCicsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitExecCicsStatement(s)
	}
}

func (s *ExecCicsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitExecCicsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) ExecCicsStatement() (localctx IExecCicsStatementContext) {
	localctx = NewExecCicsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Cobol85PreprocessorParserRULE_execCicsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(Cobol85PreprocessorParserEXEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(452)
		p.Match(Cobol85PreprocessorParserCICS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(453)
		p.CharData()
	}
	{
		p.SetState(454)
		p.Match(Cobol85PreprocessorParserEND_EXEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(455)
			p.Match(Cobol85PreprocessorParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecSqlStatementContext is an interface to support dynamic dispatch.
type IExecSqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXEC() antlr.TerminalNode
	SQL() antlr.TerminalNode
	CharDataSql() ICharDataSqlContext
	END_EXEC() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsExecSqlStatementContext differentiates from other interfaces.
	IsExecSqlStatementContext()
}

type ExecSqlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecSqlStatementContext() *ExecSqlStatementContext {
	var p = new(ExecSqlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_execSqlStatement
	return p
}

func InitEmptyExecSqlStatementContext(p *ExecSqlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_execSqlStatement
}

func (*ExecSqlStatementContext) IsExecSqlStatementContext() {}

func NewExecSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecSqlStatementContext {
	var p = new(ExecSqlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_execSqlStatement

	return p
}

func (s *ExecSqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecSqlStatementContext) EXEC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXEC, 0)
}

func (s *ExecSqlStatementContext) SQL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSQL, 0)
}

func (s *ExecSqlStatementContext) CharDataSql() ICharDataSqlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataSqlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataSqlContext)
}

func (s *ExecSqlStatementContext) END_EXEC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEND_EXEC, 0)
}

func (s *ExecSqlStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *ExecSqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecSqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecSqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterExecSqlStatement(s)
	}
}

func (s *ExecSqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitExecSqlStatement(s)
	}
}

func (s *ExecSqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitExecSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) ExecSqlStatement() (localctx IExecSqlStatementContext) {
	localctx = NewExecSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Cobol85PreprocessorParserRULE_execSqlStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(Cobol85PreprocessorParserEXEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(459)
		p.Match(Cobol85PreprocessorParserSQL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(460)
		p.CharDataSql()
	}
	{
		p.SetState(461)
		p.Match(Cobol85PreprocessorParserEND_EXEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(462)
			p.Match(Cobol85PreprocessorParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecSqlImsStatementContext is an interface to support dynamic dispatch.
type IExecSqlImsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXEC() antlr.TerminalNode
	SQLIMS() antlr.TerminalNode
	CharData() ICharDataContext
	END_EXEC() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsExecSqlImsStatementContext differentiates from other interfaces.
	IsExecSqlImsStatementContext()
}

type ExecSqlImsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecSqlImsStatementContext() *ExecSqlImsStatementContext {
	var p = new(ExecSqlImsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_execSqlImsStatement
	return p
}

func InitEmptyExecSqlImsStatementContext(p *ExecSqlImsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_execSqlImsStatement
}

func (*ExecSqlImsStatementContext) IsExecSqlImsStatementContext() {}

func NewExecSqlImsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecSqlImsStatementContext {
	var p = new(ExecSqlImsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_execSqlImsStatement

	return p
}

func (s *ExecSqlImsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecSqlImsStatementContext) EXEC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXEC, 0)
}

func (s *ExecSqlImsStatementContext) SQLIMS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSQLIMS, 0)
}

func (s *ExecSqlImsStatementContext) CharData() ICharDataContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataContext)
}

func (s *ExecSqlImsStatementContext) END_EXEC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEND_EXEC, 0)
}

func (s *ExecSqlImsStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *ExecSqlImsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecSqlImsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecSqlImsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterExecSqlImsStatement(s)
	}
}

func (s *ExecSqlImsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitExecSqlImsStatement(s)
	}
}

func (s *ExecSqlImsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitExecSqlImsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) ExecSqlImsStatement() (localctx IExecSqlImsStatementContext) {
	localctx = NewExecSqlImsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Cobol85PreprocessorParserRULE_execSqlImsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(465)
		p.Match(Cobol85PreprocessorParserEXEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(466)
		p.Match(Cobol85PreprocessorParserSQLIMS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(467)
		p.CharData()
	}
	{
		p.SetState(468)
		p.Match(Cobol85PreprocessorParserEND_EXEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(469)
			p.Match(Cobol85PreprocessorParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopyStatementContext is an interface to support dynamic dispatch.
type ICopyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COPY() antlr.TerminalNode
	CopySource() ICopySourceContext
	DOT() antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllDirectoryPhrase() []IDirectoryPhraseContext
	DirectoryPhrase(i int) IDirectoryPhraseContext
	AllFamilyPhrase() []IFamilyPhraseContext
	FamilyPhrase(i int) IFamilyPhraseContext
	AllPrefixingPhrase() []IPrefixingPhraseContext
	PrefixingPhrase(i int) IPrefixingPhraseContext
	AllReplacingPhrase() []IReplacingPhraseContext
	ReplacingPhrase(i int) IReplacingPhraseContext
	AllSUPPRESS() []antlr.TerminalNode
	SUPPRESS(i int) antlr.TerminalNode

	// IsCopyStatementContext differentiates from other interfaces.
	IsCopyStatementContext()
}

type CopyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopyStatementContext() *CopyStatementContext {
	var p = new(CopyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_copyStatement
	return p
}

func InitEmptyCopyStatementContext(p *CopyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_copyStatement
}

func (*CopyStatementContext) IsCopyStatementContext() {}

func NewCopyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopyStatementContext {
	var p = new(CopyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_copyStatement

	return p
}

func (s *CopyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CopyStatementContext) COPY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOPY, 0)
}

func (s *CopyStatementContext) CopySource() ICopySourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopySourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopySourceContext)
}

func (s *CopyStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *CopyStatementContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *CopyStatementContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *CopyStatementContext) AllDirectoryPhrase() []IDirectoryPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectoryPhraseContext); ok {
			len++
		}
	}

	tst := make([]IDirectoryPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectoryPhraseContext); ok {
			tst[i] = t.(IDirectoryPhraseContext)
			i++
		}
	}

	return tst
}

func (s *CopyStatementContext) DirectoryPhrase(i int) IDirectoryPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectoryPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectoryPhraseContext)
}

func (s *CopyStatementContext) AllFamilyPhrase() []IFamilyPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFamilyPhraseContext); ok {
			len++
		}
	}

	tst := make([]IFamilyPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFamilyPhraseContext); ok {
			tst[i] = t.(IFamilyPhraseContext)
			i++
		}
	}

	return tst
}

func (s *CopyStatementContext) FamilyPhrase(i int) IFamilyPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamilyPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamilyPhraseContext)
}

func (s *CopyStatementContext) AllPrefixingPhrase() []IPrefixingPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrefixingPhraseContext); ok {
			len++
		}
	}

	tst := make([]IPrefixingPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrefixingPhraseContext); ok {
			tst[i] = t.(IPrefixingPhraseContext)
			i++
		}
	}

	return tst
}

func (s *CopyStatementContext) PrefixingPhrase(i int) IPrefixingPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixingPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixingPhraseContext)
}

func (s *CopyStatementContext) AllReplacingPhrase() []IReplacingPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplacingPhraseContext); ok {
			len++
		}
	}

	tst := make([]IReplacingPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplacingPhraseContext); ok {
			tst[i] = t.(IReplacingPhraseContext)
			i++
		}
	}

	return tst
}

func (s *CopyStatementContext) ReplacingPhrase(i int) IReplacingPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacingPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacingPhraseContext)
}

func (s *CopyStatementContext) AllSUPPRESS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserSUPPRESS)
}

func (s *CopyStatementContext) SUPPRESS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSUPPRESS, i)
}

func (s *CopyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCopyStatement(s)
	}
}

func (s *CopyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCopyStatement(s)
	}
}

func (s *CopyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCopyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CopyStatement() (localctx ICopyStatementContext) {
	localctx = NewCopyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Cobol85PreprocessorParserRULE_copyStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.Match(Cobol85PreprocessorParserCOPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(473)
		p.CopySource()
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(477)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == Cobol85PreprocessorParserNEWLINE {
				{
					p.SetState(474)
					p.Match(Cobol85PreprocessorParserNEWLINE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(479)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(485)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Cobol85PreprocessorParserIN, Cobol85PreprocessorParserOF:
				{
					p.SetState(480)
					p.DirectoryPhrase()
				}

			case Cobol85PreprocessorParserON:
				{
					p.SetState(481)
					p.FamilyPhrase()
				}

			case Cobol85PreprocessorParserPREFIXING:
				{
					p.SetState(482)
					p.PrefixingPhrase()
				}

			case Cobol85PreprocessorParserREPLACING:
				{
					p.SetState(483)
					p.ReplacingPhrase()
				}

			case Cobol85PreprocessorParserSUPPRESS:
				{
					p.SetState(484)
					p.Match(Cobol85PreprocessorParserSUPPRESS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85PreprocessorParserNEWLINE {
		{
			p.SetState(492)
			p.Match(Cobol85PreprocessorParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(498)
		p.Match(Cobol85PreprocessorParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopySourceContext is an interface to support dynamic dispatch.
type ICopySourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	CobolWord() ICobolWordContext
	Filename() IFilenameContext
	CopyLibrary() ICopyLibraryContext
	OF() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCopySourceContext differentiates from other interfaces.
	IsCopySourceContext()
}

type CopySourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopySourceContext() *CopySourceContext {
	var p = new(CopySourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_copySource
	return p
}

func InitEmptyCopySourceContext(p *CopySourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_copySource
}

func (*CopySourceContext) IsCopySourceContext() {}

func NewCopySourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopySourceContext {
	var p = new(CopySourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_copySource

	return p
}

func (s *CopySourceContext) GetParser() antlr.Parser { return s.parser }

func (s *CopySourceContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CopySourceContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CopySourceContext) Filename() IFilenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilenameContext)
}

func (s *CopySourceContext) CopyLibrary() ICopyLibraryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopyLibraryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopyLibraryContext)
}

func (s *CopySourceContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOF, 0)
}

func (s *CopySourceContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserIN, 0)
}

func (s *CopySourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopySourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopySourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCopySource(s)
	}
}

func (s *CopySourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCopySource(s)
	}
}

func (s *CopySourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCopySource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CopySource() (localctx ICopySourceContext) {
	localctx = NewCopySourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Cobol85PreprocessorParserRULE_copySource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL:
		{
			p.SetState(500)
			p.Literal()
		}

	case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR, Cobol85PreprocessorParserIDENTIFIER:
		{
			p.SetState(501)
			p.CobolWord()
		}

	case Cobol85PreprocessorParserFILENAME:
		{
			p.SetState(502)
			p.Filename()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(505)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85PreprocessorParserIN || _la == Cobol85PreprocessorParserOF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(506)
			p.CopyLibrary()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopyLibraryContext is an interface to support dynamic dispatch.
type ICopyLibraryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	CobolWord() ICobolWordContext

	// IsCopyLibraryContext differentiates from other interfaces.
	IsCopyLibraryContext()
}

type CopyLibraryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopyLibraryContext() *CopyLibraryContext {
	var p = new(CopyLibraryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_copyLibrary
	return p
}

func InitEmptyCopyLibraryContext(p *CopyLibraryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_copyLibrary
}

func (*CopyLibraryContext) IsCopyLibraryContext() {}

func NewCopyLibraryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CopyLibraryContext {
	var p = new(CopyLibraryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_copyLibrary

	return p
}

func (s *CopyLibraryContext) GetParser() antlr.Parser { return s.parser }

func (s *CopyLibraryContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CopyLibraryContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CopyLibraryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyLibraryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CopyLibraryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCopyLibrary(s)
	}
}

func (s *CopyLibraryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCopyLibrary(s)
	}
}

func (s *CopyLibraryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCopyLibrary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CopyLibrary() (localctx ICopyLibraryContext) {
	localctx = NewCopyLibraryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Cobol85PreprocessorParserRULE_copyLibrary)
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(509)
			p.Literal()
		}

	case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR, Cobol85PreprocessorParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(510)
			p.CobolWord()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrefixingPhraseContext is an interface to support dynamic dispatch.
type IPrefixingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREFIXING() antlr.TerminalNode
	PrefixWord() IPrefixWordContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsPrefixingPhraseContext differentiates from other interfaces.
	IsPrefixingPhraseContext()
}

type PrefixingPhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixingPhraseContext() *PrefixingPhraseContext {
	var p = new(PrefixingPhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_prefixingPhrase
	return p
}

func InitEmptyPrefixingPhraseContext(p *PrefixingPhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_prefixingPhrase
}

func (*PrefixingPhraseContext) IsPrefixingPhraseContext() {}

func NewPrefixingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixingPhraseContext {
	var p = new(PrefixingPhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_prefixingPhrase

	return p
}

func (s *PrefixingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixingPhraseContext) PREFIXING() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPREFIXING, 0)
}

func (s *PrefixingPhraseContext) PrefixWord() IPrefixWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrefixWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrefixWordContext)
}

func (s *PrefixingPhraseContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *PrefixingPhraseContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *PrefixingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterPrefixingPhrase(s)
	}
}

func (s *PrefixingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitPrefixingPhrase(s)
	}
}

func (s *PrefixingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitPrefixingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) PrefixingPhrase() (localctx IPrefixingPhraseContext) {
	localctx = NewPrefixingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Cobol85PreprocessorParserRULE_prefixingPhrase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Match(Cobol85PreprocessorParserPREFIXING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85PreprocessorParserNEWLINE {
		{
			p.SetState(514)
			p.Match(Cobol85PreprocessorParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(520)
		p.PrefixWord()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacingPhraseContext is an interface to support dynamic dispatch.
type IReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACING() antlr.TerminalNode
	AllReplaceClause() []IReplaceClauseContext
	ReplaceClause(i int) IReplaceClauseContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsReplacingPhraseContext differentiates from other interfaces.
	IsReplacingPhraseContext()
}

type ReplacingPhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplacingPhraseContext() *ReplacingPhraseContext {
	var p = new(ReplacingPhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replacingPhrase
	return p
}

func InitEmptyReplacingPhraseContext(p *ReplacingPhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replacingPhrase
}

func (*ReplacingPhraseContext) IsReplacingPhraseContext() {}

func NewReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacingPhraseContext {
	var p = new(ReplacingPhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_replacingPhrase

	return p
}

func (s *ReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserREPLACING, 0)
}

func (s *ReplacingPhraseContext) AllReplaceClause() []IReplaceClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplaceClauseContext); ok {
			len++
		}
	}

	tst := make([]IReplaceClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplaceClauseContext); ok {
			tst[i] = t.(IReplaceClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReplacingPhraseContext) ReplaceClause(i int) IReplaceClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceClauseContext)
}

func (s *ReplacingPhraseContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *ReplacingPhraseContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *ReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterReplacingPhrase(s)
	}
}

func (s *ReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitReplacingPhrase(s)
	}
}

func (s *ReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) ReplacingPhrase() (localctx IReplacingPhraseContext) {
	localctx = NewReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Cobol85PreprocessorParserRULE_replacingPhrase)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)
		p.Match(Cobol85PreprocessorParserREPLACING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85PreprocessorParserNEWLINE {
		{
			p.SetState(523)
			p.Match(Cobol85PreprocessorParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(529)
		p.ReplaceClause()
	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(531)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == Cobol85PreprocessorParserNEWLINE {
				{
					p.SetState(530)
					p.Match(Cobol85PreprocessorParserNEWLINE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(533)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(535)
				p.ReplaceClause()
			}

		}
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceAreaContext is an interface to support dynamic dispatch.
type IReplaceAreaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReplaceByStatement() IReplaceByStatementContext
	AllCopyStatement() []ICopyStatementContext
	CopyStatement(i int) ICopyStatementContext
	AllCharData() []ICharDataContext
	CharData(i int) ICharDataContext
	ReplaceOffStatement() IReplaceOffStatementContext

	// IsReplaceAreaContext differentiates from other interfaces.
	IsReplaceAreaContext()
}

type ReplaceAreaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceAreaContext() *ReplaceAreaContext {
	var p = new(ReplaceAreaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceArea
	return p
}

func InitEmptyReplaceAreaContext(p *ReplaceAreaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceArea
}

func (*ReplaceAreaContext) IsReplaceAreaContext() {}

func NewReplaceAreaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceAreaContext {
	var p = new(ReplaceAreaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceArea

	return p
}

func (s *ReplaceAreaContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceAreaContext) ReplaceByStatement() IReplaceByStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceByStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceByStatementContext)
}

func (s *ReplaceAreaContext) AllCopyStatement() []ICopyStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopyStatementContext); ok {
			len++
		}
	}

	tst := make([]ICopyStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopyStatementContext); ok {
			tst[i] = t.(ICopyStatementContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceAreaContext) CopyStatement(i int) ICopyStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopyStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopyStatementContext)
}

func (s *ReplaceAreaContext) AllCharData() []ICharDataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICharDataContext); ok {
			len++
		}
	}

	tst := make([]ICharDataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICharDataContext); ok {
			tst[i] = t.(ICharDataContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceAreaContext) CharData(i int) ICharDataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataContext)
}

func (s *ReplaceAreaContext) ReplaceOffStatement() IReplaceOffStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceOffStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceOffStatementContext)
}

func (s *ReplaceAreaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceAreaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceAreaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterReplaceArea(s)
	}
}

func (s *ReplaceAreaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitReplaceArea(s)
	}
}

func (s *ReplaceAreaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitReplaceArea(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) ReplaceArea() (localctx IReplaceAreaContext) {
	localctx = NewReplaceAreaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Cobol85PreprocessorParserRULE_replaceArea)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.ReplaceByStatement()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(544)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Cobol85PreprocessorParserCOPY:
				{
					p.SetState(542)
					p.CopyStatement()
				}

			case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLPARENCHAR, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserRPARENCHAR, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR, Cobol85PreprocessorParserDOT, Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL, Cobol85PreprocessorParserIDENTIFIER, Cobol85PreprocessorParserFILENAME, Cobol85PreprocessorParserNEWLINE, Cobol85PreprocessorParserTEXT:
				{
					p.SetState(543)
					p.CharData()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(549)
			p.ReplaceOffStatement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceByStatementContext is an interface to support dynamic dispatch.
type IReplaceByStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	DOT() antlr.TerminalNode
	AllReplaceClause() []IReplaceClauseContext
	ReplaceClause(i int) IReplaceClauseContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsReplaceByStatementContext differentiates from other interfaces.
	IsReplaceByStatementContext()
}

type ReplaceByStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceByStatementContext() *ReplaceByStatementContext {
	var p = new(ReplaceByStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceByStatement
	return p
}

func InitEmptyReplaceByStatementContext(p *ReplaceByStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceByStatement
}

func (*ReplaceByStatementContext) IsReplaceByStatementContext() {}

func NewReplaceByStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceByStatementContext {
	var p = new(ReplaceByStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceByStatement

	return p
}

func (s *ReplaceByStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceByStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserREPLACE, 0)
}

func (s *ReplaceByStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *ReplaceByStatementContext) AllReplaceClause() []IReplaceClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplaceClauseContext); ok {
			len++
		}
	}

	tst := make([]IReplaceClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplaceClauseContext); ok {
			tst[i] = t.(IReplaceClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReplaceByStatementContext) ReplaceClause(i int) IReplaceClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceClauseContext)
}

func (s *ReplaceByStatementContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *ReplaceByStatementContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *ReplaceByStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceByStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceByStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterReplaceByStatement(s)
	}
}

func (s *ReplaceByStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitReplaceByStatement(s)
	}
}

func (s *ReplaceByStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitReplaceByStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) ReplaceByStatement() (localctx IReplaceByStatementContext) {
	localctx = NewReplaceByStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Cobol85PreprocessorParserRULE_replaceByStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Match(Cobol85PreprocessorParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(556)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == Cobol85PreprocessorParserNEWLINE {
				{
					p.SetState(553)
					p.Match(Cobol85PreprocessorParserNEWLINE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(558)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(559)
				p.ReplaceClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(564)
		p.Match(Cobol85PreprocessorParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceOffStatementContext is an interface to support dynamic dispatch.
type IReplaceOffStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	OFF() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsReplaceOffStatementContext differentiates from other interfaces.
	IsReplaceOffStatementContext()
}

type ReplaceOffStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceOffStatementContext() *ReplaceOffStatementContext {
	var p = new(ReplaceOffStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceOffStatement
	return p
}

func InitEmptyReplaceOffStatementContext(p *ReplaceOffStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceOffStatement
}

func (*ReplaceOffStatementContext) IsReplaceOffStatementContext() {}

func NewReplaceOffStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceOffStatementContext {
	var p = new(ReplaceOffStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceOffStatement

	return p
}

func (s *ReplaceOffStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceOffStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserREPLACE, 0)
}

func (s *ReplaceOffStatementContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOFF, 0)
}

func (s *ReplaceOffStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *ReplaceOffStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceOffStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceOffStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterReplaceOffStatement(s)
	}
}

func (s *ReplaceOffStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitReplaceOffStatement(s)
	}
}

func (s *ReplaceOffStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitReplaceOffStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) ReplaceOffStatement() (localctx IReplaceOffStatementContext) {
	localctx = NewReplaceOffStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Cobol85PreprocessorParserRULE_replaceOffStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(Cobol85PreprocessorParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(567)
		p.Match(Cobol85PreprocessorParserOFF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(568)
		p.Match(Cobol85PreprocessorParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceClauseContext is an interface to support dynamic dispatch.
type IReplaceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Replaceable() IReplaceableContext
	BY() antlr.TerminalNode
	Replacement() IReplacementContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	DirectoryPhrase() IDirectoryPhraseContext
	FamilyPhrase() IFamilyPhraseContext

	// IsReplaceClauseContext differentiates from other interfaces.
	IsReplaceClauseContext()
}

type ReplaceClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceClauseContext() *ReplaceClauseContext {
	var p = new(ReplaceClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceClause
	return p
}

func InitEmptyReplaceClauseContext(p *ReplaceClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceClause
}

func (*ReplaceClauseContext) IsReplaceClauseContext() {}

func NewReplaceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceClauseContext {
	var p = new(ReplaceClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceClause

	return p
}

func (s *ReplaceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceClauseContext) Replaceable() IReplaceableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceableContext)
}

func (s *ReplaceClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBY, 0)
}

func (s *ReplaceClauseContext) Replacement() IReplacementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacementContext)
}

func (s *ReplaceClauseContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *ReplaceClauseContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *ReplaceClauseContext) DirectoryPhrase() IDirectoryPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectoryPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectoryPhraseContext)
}

func (s *ReplaceClauseContext) FamilyPhrase() IFamilyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFamilyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFamilyPhraseContext)
}

func (s *ReplaceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterReplaceClause(s)
	}
}

func (s *ReplaceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitReplaceClause(s)
	}
}

func (s *ReplaceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitReplaceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) ReplaceClause() (localctx IReplaceClauseContext) {
	localctx = NewReplaceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Cobol85PreprocessorParserRULE_replaceClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.Replaceable()
	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85PreprocessorParserNEWLINE {
		{
			p.SetState(571)
			p.Match(Cobol85PreprocessorParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(577)
		p.Match(Cobol85PreprocessorParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85PreprocessorParserNEWLINE {
		{
			p.SetState(578)
			p.Match(Cobol85PreprocessorParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(584)
		p.Replacement()
	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		p.SetState(588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85PreprocessorParserNEWLINE {
			{
				p.SetState(585)
				p.Match(Cobol85PreprocessorParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(590)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(591)
			p.DirectoryPhrase()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85PreprocessorParserNEWLINE {
			{
				p.SetState(594)
				p.Match(Cobol85PreprocessorParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(599)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(600)
			p.FamilyPhrase()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectoryPhraseContext is an interface to support dynamic dispatch.
type IDirectoryPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OF() antlr.TerminalNode
	IN() antlr.TerminalNode
	Literal() ILiteralContext
	CobolWord() ICobolWordContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsDirectoryPhraseContext differentiates from other interfaces.
	IsDirectoryPhraseContext()
}

type DirectoryPhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectoryPhraseContext() *DirectoryPhraseContext {
	var p = new(DirectoryPhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_directoryPhrase
	return p
}

func InitEmptyDirectoryPhraseContext(p *DirectoryPhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_directoryPhrase
}

func (*DirectoryPhraseContext) IsDirectoryPhraseContext() {}

func NewDirectoryPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectoryPhraseContext {
	var p = new(DirectoryPhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_directoryPhrase

	return p
}

func (s *DirectoryPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectoryPhraseContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOF, 0)
}

func (s *DirectoryPhraseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserIN, 0)
}

func (s *DirectoryPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DirectoryPhraseContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DirectoryPhraseContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *DirectoryPhraseContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *DirectoryPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectoryPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectoryPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterDirectoryPhrase(s)
	}
}

func (s *DirectoryPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitDirectoryPhrase(s)
	}
}

func (s *DirectoryPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitDirectoryPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) DirectoryPhrase() (localctx IDirectoryPhraseContext) {
	localctx = NewDirectoryPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Cobol85PreprocessorParserRULE_directoryPhrase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85PreprocessorParserIN || _la == Cobol85PreprocessorParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85PreprocessorParserNEWLINE {
		{
			p.SetState(604)
			p.Match(Cobol85PreprocessorParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL:
		{
			p.SetState(610)
			p.Literal()
		}

	case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR, Cobol85PreprocessorParserIDENTIFIER:
		{
			p.SetState(611)
			p.CobolWord()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFamilyPhraseContext is an interface to support dynamic dispatch.
type IFamilyPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Literal() ILiteralContext
	CobolWord() ICobolWordContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsFamilyPhraseContext differentiates from other interfaces.
	IsFamilyPhraseContext()
}

type FamilyPhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFamilyPhraseContext() *FamilyPhraseContext {
	var p = new(FamilyPhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_familyPhrase
	return p
}

func InitEmptyFamilyPhraseContext(p *FamilyPhraseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_familyPhrase
}

func (*FamilyPhraseContext) IsFamilyPhraseContext() {}

func NewFamilyPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FamilyPhraseContext {
	var p = new(FamilyPhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_familyPhrase

	return p
}

func (s *FamilyPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *FamilyPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserON, 0)
}

func (s *FamilyPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *FamilyPhraseContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *FamilyPhraseContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *FamilyPhraseContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *FamilyPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FamilyPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FamilyPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterFamilyPhrase(s)
	}
}

func (s *FamilyPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitFamilyPhrase(s)
	}
}

func (s *FamilyPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitFamilyPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) FamilyPhrase() (localctx IFamilyPhraseContext) {
	localctx = NewFamilyPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Cobol85PreprocessorParserRULE_familyPhrase)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Match(Cobol85PreprocessorParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85PreprocessorParserNEWLINE {
		{
			p.SetState(615)
			p.Match(Cobol85PreprocessorParserNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL:
		{
			p.SetState(621)
			p.Literal()
		}

	case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR, Cobol85PreprocessorParserIDENTIFIER:
		{
			p.SetState(622)
			p.CobolWord()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceableContext is an interface to support dynamic dispatch.
type IReplaceableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	CobolWord() ICobolWordContext
	PseudoText() IPseudoTextContext
	CharDataLine() ICharDataLineContext

	// IsReplaceableContext differentiates from other interfaces.
	IsReplaceableContext()
}

type ReplaceableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceableContext() *ReplaceableContext {
	var p = new(ReplaceableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceable
	return p
}

func InitEmptyReplaceableContext(p *ReplaceableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceable
}

func (*ReplaceableContext) IsReplaceableContext() {}

func NewReplaceableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceableContext {
	var p = new(ReplaceableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_replaceable

	return p
}

func (s *ReplaceableContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceableContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ReplaceableContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ReplaceableContext) PseudoText() IPseudoTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPseudoTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPseudoTextContext)
}

func (s *ReplaceableContext) CharDataLine() ICharDataLineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataLineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataLineContext)
}

func (s *ReplaceableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterReplaceable(s)
	}
}

func (s *ReplaceableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitReplaceable(s)
	}
}

func (s *ReplaceableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitReplaceable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) Replaceable() (localctx IReplaceableContext) {
	localctx = NewReplaceableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Cobol85PreprocessorParserRULE_replaceable)
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(625)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(626)
			p.CobolWord()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(627)
			p.PseudoText()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(628)
			p.CharDataLine()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacementContext is an interface to support dynamic dispatch.
type IReplacementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	CobolWord() ICobolWordContext
	PseudoText() IPseudoTextContext
	CharDataLine() ICharDataLineContext

	// IsReplacementContext differentiates from other interfaces.
	IsReplacementContext()
}

type ReplacementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplacementContext() *ReplacementContext {
	var p = new(ReplacementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replacement
	return p
}

func InitEmptyReplacementContext(p *ReplacementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_replacement
}

func (*ReplacementContext) IsReplacementContext() {}

func NewReplacementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacementContext {
	var p = new(ReplacementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_replacement

	return p
}

func (s *ReplacementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ReplacementContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ReplacementContext) PseudoText() IPseudoTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPseudoTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPseudoTextContext)
}

func (s *ReplacementContext) CharDataLine() ICharDataLineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataLineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataLineContext)
}

func (s *ReplacementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterReplacement(s)
	}
}

func (s *ReplacementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitReplacement(s)
	}
}

func (s *ReplacementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitReplacement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) Replacement() (localctx IReplacementContext) {
	localctx = NewReplacementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Cobol85PreprocessorParserRULE_replacement)
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.CobolWord()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(633)
			p.PseudoText()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(634)
			p.CharDataLine()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEjectStatementContext is an interface to support dynamic dispatch.
type IEjectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EJECT() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsEjectStatementContext differentiates from other interfaces.
	IsEjectStatementContext()
}

type EjectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEjectStatementContext() *EjectStatementContext {
	var p = new(EjectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_ejectStatement
	return p
}

func InitEmptyEjectStatementContext(p *EjectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_ejectStatement
}

func (*EjectStatementContext) IsEjectStatementContext() {}

func NewEjectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EjectStatementContext {
	var p = new(EjectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_ejectStatement

	return p
}

func (s *EjectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EjectStatementContext) EJECT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEJECT, 0)
}

func (s *EjectStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *EjectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EjectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EjectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterEjectStatement(s)
	}
}

func (s *EjectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitEjectStatement(s)
	}
}

func (s *EjectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitEjectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) EjectStatement() (localctx IEjectStatementContext) {
	localctx = NewEjectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Cobol85PreprocessorParserRULE_ejectStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Match(Cobol85PreprocessorParserEJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(639)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(638)
			p.Match(Cobol85PreprocessorParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkipStatementContext is an interface to support dynamic dispatch.
type ISkipStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SKIP1() antlr.TerminalNode
	SKIP2() antlr.TerminalNode
	SKIP3() antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsSkipStatementContext differentiates from other interfaces.
	IsSkipStatementContext()
}

type SkipStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkipStatementContext() *SkipStatementContext {
	var p = new(SkipStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_skipStatement
	return p
}

func InitEmptySkipStatementContext(p *SkipStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_skipStatement
}

func (*SkipStatementContext) IsSkipStatementContext() {}

func NewSkipStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipStatementContext {
	var p = new(SkipStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_skipStatement

	return p
}

func (s *SkipStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipStatementContext) SKIP1() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSKIP1, 0)
}

func (s *SkipStatementContext) SKIP2() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSKIP2, 0)
}

func (s *SkipStatementContext) SKIP3() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSKIP3, 0)
}

func (s *SkipStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *SkipStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterSkipStatement(s)
	}
}

func (s *SkipStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitSkipStatement(s)
	}
}

func (s *SkipStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitSkipStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) SkipStatement() (localctx ISkipStatementContext) {
	localctx = NewSkipStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Cobol85PreprocessorParserRULE_skipStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-239)) & ^0x3f) == 0 && ((int64(1)<<(_la-239))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(642)
			p.Match(Cobol85PreprocessorParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITitleStatementContext is an interface to support dynamic dispatch.
type ITitleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TITLE() antlr.TerminalNode
	Literal() ILiteralContext
	DOT() antlr.TerminalNode

	// IsTitleStatementContext differentiates from other interfaces.
	IsTitleStatementContext()
}

type TitleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTitleStatementContext() *TitleStatementContext {
	var p = new(TitleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_titleStatement
	return p
}

func InitEmptyTitleStatementContext(p *TitleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_titleStatement
}

func (*TitleStatementContext) IsTitleStatementContext() {}

func NewTitleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TitleStatementContext {
	var p = new(TitleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_titleStatement

	return p
}

func (s *TitleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TitleStatementContext) TITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTITLE, 0)
}

func (s *TitleStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *TitleStatementContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, 0)
}

func (s *TitleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TitleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TitleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterTitleStatement(s)
	}
}

func (s *TitleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitTitleStatement(s)
	}
}

func (s *TitleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitTitleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) TitleStatement() (localctx ITitleStatementContext) {
	localctx = NewTitleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Cobol85PreprocessorParserRULE_titleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Match(Cobol85PreprocessorParserTITLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(646)
		p.Literal()
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(647)
			p.Match(Cobol85PreprocessorParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPseudoTextContext is an interface to support dynamic dispatch.
type IPseudoTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDOUBLEEQUALCHAR() []antlr.TerminalNode
	DOUBLEEQUALCHAR(i int) antlr.TerminalNode
	CharData() ICharDataContext

	// IsPseudoTextContext differentiates from other interfaces.
	IsPseudoTextContext()
}

type PseudoTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPseudoTextContext() *PseudoTextContext {
	var p = new(PseudoTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_pseudoText
	return p
}

func InitEmptyPseudoTextContext(p *PseudoTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_pseudoText
}

func (*PseudoTextContext) IsPseudoTextContext() {}

func NewPseudoTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PseudoTextContext {
	var p = new(PseudoTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_pseudoText

	return p
}

func (s *PseudoTextContext) GetParser() antlr.Parser { return s.parser }

func (s *PseudoTextContext) AllDOUBLEEQUALCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserDOUBLEEQUALCHAR)
}

func (s *PseudoTextContext) DOUBLEEQUALCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOUBLEEQUALCHAR, i)
}

func (s *PseudoTextContext) CharData() ICharDataContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataContext)
}

func (s *PseudoTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PseudoTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PseudoTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterPseudoText(s)
	}
}

func (s *PseudoTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitPseudoText(s)
	}
}

func (s *PseudoTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitPseudoText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) PseudoText() (localctx IPseudoTextContext) {
	localctx = NewPseudoTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Cobol85PreprocessorParserRULE_pseudoText)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Match(Cobol85PreprocessorParserDOUBLEEQUALCHAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2346375405893844994) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8193) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-288230376151711745) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-19069930225795073) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&325813534447) != 0) {
		{
			p.SetState(651)
			p.CharData()
		}

	}
	{
		p.SetState(654)
		p.Match(Cobol85PreprocessorParserDOUBLEEQUALCHAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharDataContext is an interface to support dynamic dispatch.
type ICharDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCharDataLine() []ICharDataLineContext
	CharDataLine(i int) ICharDataLineContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsCharDataContext differentiates from other interfaces.
	IsCharDataContext()
}

type CharDataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharDataContext() *CharDataContext {
	var p = new(CharDataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_charData
	return p
}

func InitEmptyCharDataContext(p *CharDataContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_charData
}

func (*CharDataContext) IsCharDataContext() {}

func NewCharDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharDataContext {
	var p = new(CharDataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_charData

	return p
}

func (s *CharDataContext) GetParser() antlr.Parser { return s.parser }

func (s *CharDataContext) AllCharDataLine() []ICharDataLineContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICharDataLineContext); ok {
			len++
		}
	}

	tst := make([]ICharDataLineContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICharDataLineContext); ok {
			tst[i] = t.(ICharDataLineContext)
			i++
		}
	}

	return tst
}

func (s *CharDataContext) CharDataLine(i int) ICharDataLineContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataLineContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataLineContext)
}

func (s *CharDataContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *CharDataContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *CharDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCharData(s)
	}
}

func (s *CharDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCharData(s)
	}
}

func (s *CharDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCharData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CharData() (localctx ICharDataContext) {
	localctx = NewCharDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Cobol85PreprocessorParserRULE_charData)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(658)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLPARENCHAR, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserRPARENCHAR, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR, Cobol85PreprocessorParserDOT, Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL, Cobol85PreprocessorParserIDENTIFIER, Cobol85PreprocessorParserFILENAME, Cobol85PreprocessorParserTEXT:
				{
					p.SetState(656)
					p.CharDataLine()
				}

			case Cobol85PreprocessorParserNEWLINE:
				{
					p.SetState(657)
					p.Match(Cobol85PreprocessorParserNEWLINE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharDataSqlContext is an interface to support dynamic dispatch.
type ICharDataSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCharDataLine() []ICharDataLineContext
	CharDataLine(i int) ICharDataLineContext
	AllCOPY() []antlr.TerminalNode
	COPY(i int) antlr.TerminalNode
	AllREPLACE() []antlr.TerminalNode
	REPLACE(i int) antlr.TerminalNode
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode

	// IsCharDataSqlContext differentiates from other interfaces.
	IsCharDataSqlContext()
}

type CharDataSqlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharDataSqlContext() *CharDataSqlContext {
	var p = new(CharDataSqlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataSql
	return p
}

func InitEmptyCharDataSqlContext(p *CharDataSqlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataSql
}

func (*CharDataSqlContext) IsCharDataSqlContext() {}

func NewCharDataSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharDataSqlContext {
	var p = new(CharDataSqlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataSql

	return p
}

func (s *CharDataSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *CharDataSqlContext) AllCharDataLine() []ICharDataLineContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICharDataLineContext); ok {
			len++
		}
	}

	tst := make([]ICharDataLineContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICharDataLineContext); ok {
			tst[i] = t.(ICharDataLineContext)
			i++
		}
	}

	return tst
}

func (s *CharDataSqlContext) CharDataLine(i int) ICharDataLineContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataLineContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataLineContext)
}

func (s *CharDataSqlContext) AllCOPY() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserCOPY)
}

func (s *CharDataSqlContext) COPY(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOPY, i)
}

func (s *CharDataSqlContext) AllREPLACE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserREPLACE)
}

func (s *CharDataSqlContext) REPLACE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserREPLACE, i)
}

func (s *CharDataSqlContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserNEWLINE)
}

func (s *CharDataSqlContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNEWLINE, i)
}

func (s *CharDataSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharDataSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharDataSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCharDataSql(s)
	}
}

func (s *CharDataSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCharDataSql(s)
	}
}

func (s *CharDataSqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCharDataSql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CharDataSql() (localctx ICharDataSqlContext) {
	localctx = NewCharDataSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Cobol85PreprocessorParserRULE_charDataSql)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2346375405860290562) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8193) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-288230376151711745) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-19069929688924161) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&325813534447) != 0) {
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLPARENCHAR, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserRPARENCHAR, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR, Cobol85PreprocessorParserDOT, Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL, Cobol85PreprocessorParserIDENTIFIER, Cobol85PreprocessorParserFILENAME, Cobol85PreprocessorParserTEXT:
			{
				p.SetState(662)
				p.CharDataLine()
			}

		case Cobol85PreprocessorParserCOPY:
			{
				p.SetState(663)
				p.Match(Cobol85PreprocessorParserCOPY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Cobol85PreprocessorParserREPLACE:
			{
				p.SetState(664)
				p.Match(Cobol85PreprocessorParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case Cobol85PreprocessorParserNEWLINE:
			{
				p.SetState(665)
				p.Match(Cobol85PreprocessorParserNEWLINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharDataLineContext is an interface to support dynamic dispatch.
type ICharDataLineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCobolWord() []ICobolWordContext
	CobolWord(i int) ICobolWordContext
	AllLiteral() []ILiteralContext
	Literal(i int) ILiteralContext
	AllFilename() []IFilenameContext
	Filename(i int) IFilenameContext
	AllTEXT() []antlr.TerminalNode
	TEXT(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllLPARENCHAR() []antlr.TerminalNode
	LPARENCHAR(i int) antlr.TerminalNode
	AllRPARENCHAR() []antlr.TerminalNode
	RPARENCHAR(i int) antlr.TerminalNode

	// IsCharDataLineContext differentiates from other interfaces.
	IsCharDataLineContext()
}

type CharDataLineContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharDataLineContext() *CharDataLineContext {
	var p = new(CharDataLineContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataLine
	return p
}

func InitEmptyCharDataLineContext(p *CharDataLineContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataLine
}

func (*CharDataLineContext) IsCharDataLineContext() {}

func NewCharDataLineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharDataLineContext {
	var p = new(CharDataLineContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataLine

	return p
}

func (s *CharDataLineContext) GetParser() antlr.Parser { return s.parser }

func (s *CharDataLineContext) AllCobolWord() []ICobolWordContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICobolWordContext); ok {
			len++
		}
	}

	tst := make([]ICobolWordContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICobolWordContext); ok {
			tst[i] = t.(ICobolWordContext)
			i++
		}
	}

	return tst
}

func (s *CharDataLineContext) CobolWord(i int) ICobolWordContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CharDataLineContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *CharDataLineContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CharDataLineContext) AllFilename() []IFilenameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFilenameContext); ok {
			len++
		}
	}

	tst := make([]IFilenameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFilenameContext); ok {
			tst[i] = t.(IFilenameContext)
			i++
		}
	}

	return tst
}

func (s *CharDataLineContext) Filename(i int) IFilenameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilenameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilenameContext)
}

func (s *CharDataLineContext) AllTEXT() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserTEXT)
}

func (s *CharDataLineContext) TEXT(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTEXT, i)
}

func (s *CharDataLineContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserDOT)
}

func (s *CharDataLineContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDOT, i)
}

func (s *CharDataLineContext) AllLPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserLPARENCHAR)
}

func (s *CharDataLineContext) LPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLPARENCHAR, i)
}

func (s *CharDataLineContext) AllRPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85PreprocessorParserRPARENCHAR)
}

func (s *CharDataLineContext) RPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserRPARENCHAR, i)
}

func (s *CharDataLineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharDataLineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharDataLineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCharDataLine(s)
	}
}

func (s *CharDataLineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCharDataLine(s)
	}
}

func (s *CharDataLineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCharDataLine(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CharDataLine() (localctx ICharDataLineContext) {
	localctx = NewCharDataLineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Cobol85PreprocessorParserRULE_charDataLine)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(677)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR, Cobol85PreprocessorParserIDENTIFIER:
				{
					p.SetState(670)
					p.CobolWord()
				}

			case Cobol85PreprocessorParserNONNUMERICLITERAL, Cobol85PreprocessorParserNUMERICLITERAL:
				{
					p.SetState(671)
					p.Literal()
				}

			case Cobol85PreprocessorParserFILENAME:
				{
					p.SetState(672)
					p.Filename()
				}

			case Cobol85PreprocessorParserTEXT:
				{
					p.SetState(673)
					p.Match(Cobol85PreprocessorParserTEXT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Cobol85PreprocessorParserDOT:
				{
					p.SetState(674)
					p.Match(Cobol85PreprocessorParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Cobol85PreprocessorParserLPARENCHAR:
				{
					p.SetState(675)
					p.Match(Cobol85PreprocessorParserLPARENCHAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case Cobol85PreprocessorParserRPARENCHAR:
				{
					p.SetState(676)
					p.Match(Cobol85PreprocessorParserRPARENCHAR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICobolWordContext is an interface to support dynamic dispatch.
type ICobolWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	CharDataKeyword() ICharDataKeywordContext

	// IsCobolWordContext differentiates from other interfaces.
	IsCobolWordContext()
}

type CobolWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCobolWordContext() *CobolWordContext {
	var p = new(CobolWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_cobolWord
	return p
}

func InitEmptyCobolWordContext(p *CobolWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_cobolWord
}

func (*CobolWordContext) IsCobolWordContext() {}

func NewCobolWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CobolWordContext {
	var p = new(CobolWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_cobolWord

	return p
}

func (s *CobolWordContext) GetParser() antlr.Parser { return s.parser }

func (s *CobolWordContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserIDENTIFIER, 0)
}

func (s *CobolWordContext) CharDataKeyword() ICharDataKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharDataKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharDataKeywordContext)
}

func (s *CobolWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CobolWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CobolWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCobolWord(s)
	}
}

func (s *CobolWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCobolWord(s)
	}
}

func (s *CobolWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCobolWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CobolWord() (localctx ICobolWordContext) {
	localctx = NewCobolWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Cobol85PreprocessorParserRULE_cobolWord)
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case Cobol85PreprocessorParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.Match(Cobol85PreprocessorParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case Cobol85PreprocessorParserADATA, Cobol85PreprocessorParserADV, Cobol85PreprocessorParserALIAS, Cobol85PreprocessorParserANSI, Cobol85PreprocessorParserANY, Cobol85PreprocessorParserAPOST, Cobol85PreprocessorParserAR, Cobol85PreprocessorParserARITH, Cobol85PreprocessorParserAUTO, Cobol85PreprocessorParserAWO, Cobol85PreprocessorParserBIN, Cobol85PreprocessorParserBLOCK0, Cobol85PreprocessorParserBUF, Cobol85PreprocessorParserBUFSIZE, Cobol85PreprocessorParserBY, Cobol85PreprocessorParserCBL, Cobol85PreprocessorParserCBLCARD, Cobol85PreprocessorParserCO, Cobol85PreprocessorParserCOBOL2, Cobol85PreprocessorParserCOBOL3, Cobol85PreprocessorParserCODEPAGE, Cobol85PreprocessorParserCOMPAT, Cobol85PreprocessorParserCOMPILE, Cobol85PreprocessorParserCP, Cobol85PreprocessorParserCPP, Cobol85PreprocessorParserCPSM, Cobol85PreprocessorParserCS, Cobol85PreprocessorParserCURR, Cobol85PreprocessorParserCURRENCY, Cobol85PreprocessorParserDATA, Cobol85PreprocessorParserDATEPROC, Cobol85PreprocessorParserDBCS, Cobol85PreprocessorParserDD, Cobol85PreprocessorParserDEBUG, Cobol85PreprocessorParserDECK, Cobol85PreprocessorParserDIAGTRUNC, Cobol85PreprocessorParserDLI, Cobol85PreprocessorParserDLL, Cobol85PreprocessorParserDP, Cobol85PreprocessorParserDTR, Cobol85PreprocessorParserDU, Cobol85PreprocessorParserDUMP, Cobol85PreprocessorParserDYN, Cobol85PreprocessorParserDYNAM, Cobol85PreprocessorParserEDF, Cobol85PreprocessorParserEJECT, Cobol85PreprocessorParserEJPD, Cobol85PreprocessorParserEN, Cobol85PreprocessorParserENGLISH, Cobol85PreprocessorParserEPILOG, Cobol85PreprocessorParserEXCI, Cobol85PreprocessorParserEXIT, Cobol85PreprocessorParserEXP, Cobol85PreprocessorParserEXPORTALL, Cobol85PreprocessorParserEXTEND, Cobol85PreprocessorParserFASTSRT, Cobol85PreprocessorParserFLAG, Cobol85PreprocessorParserFLAGSTD, Cobol85PreprocessorParserFSRT, Cobol85PreprocessorParserFULL, Cobol85PreprocessorParserGDS, Cobol85PreprocessorParserGRAPHIC, Cobol85PreprocessorParserHOOK, Cobol85PreprocessorParserIN, Cobol85PreprocessorParserINTDATE, Cobol85PreprocessorParserJA, Cobol85PreprocessorParserJP, Cobol85PreprocessorParserKA, Cobol85PreprocessorParserLANG, Cobol85PreprocessorParserLANGUAGE, Cobol85PreprocessorParserLC, Cobol85PreprocessorParserLENGTH, Cobol85PreprocessorParserLIB, Cobol85PreprocessorParserLILIAN, Cobol85PreprocessorParserLIN, Cobol85PreprocessorParserLINECOUNT, Cobol85PreprocessorParserLINKAGE, Cobol85PreprocessorParserLIST, Cobol85PreprocessorParserLM, Cobol85PreprocessorParserLONGMIXED, Cobol85PreprocessorParserLONGUPPER, Cobol85PreprocessorParserLU, Cobol85PreprocessorParserMAP, Cobol85PreprocessorParserMARGINS, Cobol85PreprocessorParserMAX, Cobol85PreprocessorParserMD, Cobol85PreprocessorParserMDECK, Cobol85PreprocessorParserMIG, Cobol85PreprocessorParserMIXED, Cobol85PreprocessorParserNAME, Cobol85PreprocessorParserNAT, Cobol85PreprocessorParserNATIONAL, Cobol85PreprocessorParserNATLANG, Cobol85PreprocessorParserNN, Cobol85PreprocessorParserNO, Cobol85PreprocessorParserNOADATA, Cobol85PreprocessorParserNOADV, Cobol85PreprocessorParserNOALIAS, Cobol85PreprocessorParserNOAWO, Cobol85PreprocessorParserNOBLOCK0, Cobol85PreprocessorParserNOC, Cobol85PreprocessorParserNOCBLCARD, Cobol85PreprocessorParserNOCICS, Cobol85PreprocessorParserNOCMPR2, Cobol85PreprocessorParserNOCOMPILE, Cobol85PreprocessorParserNOCPSM, Cobol85PreprocessorParserNOCURR, Cobol85PreprocessorParserNOCURRENCY, Cobol85PreprocessorParserNOD, Cobol85PreprocessorParserNODATEPROC, Cobol85PreprocessorParserNODBCS, Cobol85PreprocessorParserNODE, Cobol85PreprocessorParserNODEBUG, Cobol85PreprocessorParserNODECK, Cobol85PreprocessorParserNODIAGTRUNC, Cobol85PreprocessorParserNODLL, Cobol85PreprocessorParserNODU, Cobol85PreprocessorParserNODUMP, Cobol85PreprocessorParserNODP, Cobol85PreprocessorParserNODTR, Cobol85PreprocessorParserNODYN, Cobol85PreprocessorParserNODYNAM, Cobol85PreprocessorParserNOEDF, Cobol85PreprocessorParserNOEJPD, Cobol85PreprocessorParserNOEPILOG, Cobol85PreprocessorParserNOEXIT, Cobol85PreprocessorParserNOEXP, Cobol85PreprocessorParserNOEXPORTALL, Cobol85PreprocessorParserNOF, Cobol85PreprocessorParserNOFASTSRT, Cobol85PreprocessorParserNOFEPI, Cobol85PreprocessorParserNOFLAG, Cobol85PreprocessorParserNOFLAGMIG, Cobol85PreprocessorParserNOFLAGSTD, Cobol85PreprocessorParserNOFSRT, Cobol85PreprocessorParserNOGRAPHIC, Cobol85PreprocessorParserNOHOOK, Cobol85PreprocessorParserNOLENGTH, Cobol85PreprocessorParserNOLIB, Cobol85PreprocessorParserNOLINKAGE, Cobol85PreprocessorParserNOLIST, Cobol85PreprocessorParserNOMAP, Cobol85PreprocessorParserNOMD, Cobol85PreprocessorParserNOMDECK, Cobol85PreprocessorParserNONAME, Cobol85PreprocessorParserNONUM, Cobol85PreprocessorParserNONUMBER, Cobol85PreprocessorParserNOOBJ, Cobol85PreprocessorParserNOOBJECT, Cobol85PreprocessorParserNOOFF, Cobol85PreprocessorParserNOOFFSET, Cobol85PreprocessorParserNOOPSEQUENCE, Cobol85PreprocessorParserNOOPT, Cobol85PreprocessorParserNOOPTIMIZE, Cobol85PreprocessorParserNOOPTIONS, Cobol85PreprocessorParserNOP, Cobol85PreprocessorParserNOPFD, Cobol85PreprocessorParserNOPROLOG, Cobol85PreprocessorParserNORENT, Cobol85PreprocessorParserNOS, Cobol85PreprocessorParserNOSEP, Cobol85PreprocessorParserNOSEPARATE, Cobol85PreprocessorParserNOSEQ, Cobol85PreprocessorParserNOSOURCE, Cobol85PreprocessorParserNOSPIE, Cobol85PreprocessorParserNOSQL, Cobol85PreprocessorParserNOSQLC, Cobol85PreprocessorParserNOSQLCCSID, Cobol85PreprocessorParserNOSSR, Cobol85PreprocessorParserNOSSRANGE, Cobol85PreprocessorParserNOSTDTRUNC, Cobol85PreprocessorParserNOSEQUENCE, Cobol85PreprocessorParserNOTERM, Cobol85PreprocessorParserNOTERMINAL, Cobol85PreprocessorParserNOTEST, Cobol85PreprocessorParserNOTHREAD, Cobol85PreprocessorParserNOTRIG, Cobol85PreprocessorParserNOVBREF, Cobol85PreprocessorParserNOWORD, Cobol85PreprocessorParserNOX, Cobol85PreprocessorParserNOXREF, Cobol85PreprocessorParserNOZWB, Cobol85PreprocessorParserNS, Cobol85PreprocessorParserNSEQ, Cobol85PreprocessorParserNSYMBOL, Cobol85PreprocessorParserNUM, Cobol85PreprocessorParserNUMBER, Cobol85PreprocessorParserNUMPROC, Cobol85PreprocessorParserOBJ, Cobol85PreprocessorParserOBJECT, Cobol85PreprocessorParserOF, Cobol85PreprocessorParserOFF, Cobol85PreprocessorParserOFFSET, Cobol85PreprocessorParserON, Cobol85PreprocessorParserOP, Cobol85PreprocessorParserOPMARGINS, Cobol85PreprocessorParserOPSEQUENCE, Cobol85PreprocessorParserOPT, Cobol85PreprocessorParserOPTFILE, Cobol85PreprocessorParserOPTIMIZE, Cobol85PreprocessorParserOPTIONS, Cobol85PreprocessorParserOUT, Cobol85PreprocessorParserOUTDD, Cobol85PreprocessorParserPFD, Cobol85PreprocessorParserPPTDBG, Cobol85PreprocessorParserPGMN, Cobol85PreprocessorParserPGMNAME, Cobol85PreprocessorParserPROCESS, Cobol85PreprocessorParserPROLOG, Cobol85PreprocessorParserQUOTE, Cobol85PreprocessorParserRENT, Cobol85PreprocessorParserREPLACING, Cobol85PreprocessorParserRMODE, Cobol85PreprocessorParserSEP, Cobol85PreprocessorParserSEPARATE, Cobol85PreprocessorParserSEQ, Cobol85PreprocessorParserSEQUENCE, Cobol85PreprocessorParserSHORT, Cobol85PreprocessorParserSIZE, Cobol85PreprocessorParserSOURCE, Cobol85PreprocessorParserSP, Cobol85PreprocessorParserSPACE, Cobol85PreprocessorParserSPIE, Cobol85PreprocessorParserSQL, Cobol85PreprocessorParserSQLC, Cobol85PreprocessorParserSQLCCSID, Cobol85PreprocessorParserSS, Cobol85PreprocessorParserSSR, Cobol85PreprocessorParserSSRANGE, Cobol85PreprocessorParserSTD, Cobol85PreprocessorParserSYSEIB, Cobol85PreprocessorParserSZ, Cobol85PreprocessorParserTERM, Cobol85PreprocessorParserTERMINAL, Cobol85PreprocessorParserTEST, Cobol85PreprocessorParserTHREAD, Cobol85PreprocessorParserTITLE, Cobol85PreprocessorParserTRIG, Cobol85PreprocessorParserTRUNC, Cobol85PreprocessorParserUE, Cobol85PreprocessorParserUPPER, Cobol85PreprocessorParserVBREF, Cobol85PreprocessorParserWD, Cobol85PreprocessorParserXMLPARSE, Cobol85PreprocessorParserXMLSS, Cobol85PreprocessorParserXOPTS, Cobol85PreprocessorParserXREF, Cobol85PreprocessorParserYEARWINDOW, Cobol85PreprocessorParserYW, Cobol85PreprocessorParserZWB, Cobol85PreprocessorParserC_CHAR, Cobol85PreprocessorParserD_CHAR, Cobol85PreprocessorParserE_CHAR, Cobol85PreprocessorParserF_CHAR, Cobol85PreprocessorParserH_CHAR, Cobol85PreprocessorParserI_CHAR, Cobol85PreprocessorParserM_CHAR, Cobol85PreprocessorParserN_CHAR, Cobol85PreprocessorParserQ_CHAR, Cobol85PreprocessorParserS_CHAR, Cobol85PreprocessorParserU_CHAR, Cobol85PreprocessorParserW_CHAR, Cobol85PreprocessorParserX_CHAR, Cobol85PreprocessorParserCOMMACHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(682)
			p.CharDataKeyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrefixWordContext is an interface to support dynamic dispatch.
type IPrefixWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREFIX() antlr.TerminalNode

	// IsPrefixWordContext differentiates from other interfaces.
	IsPrefixWordContext()
}

type PrefixWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrefixWordContext() *PrefixWordContext {
	var p = new(PrefixWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_prefixWord
	return p
}

func InitEmptyPrefixWordContext(p *PrefixWordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_prefixWord
}

func (*PrefixWordContext) IsPrefixWordContext() {}

func NewPrefixWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrefixWordContext {
	var p = new(PrefixWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_prefixWord

	return p
}

func (s *PrefixWordContext) GetParser() antlr.Parser { return s.parser }

func (s *PrefixWordContext) PREFIX() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPREFIX, 0)
}

func (s *PrefixWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrefixWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterPrefixWord(s)
	}
}

func (s *PrefixWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitPrefixWord(s)
	}
}

func (s *PrefixWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitPrefixWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) PrefixWord() (localctx IPrefixWordContext) {
	localctx = NewPrefixWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Cobol85PreprocessorParserRULE_prefixWord)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.Match(Cobol85PreprocessorParserPREFIX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NONNUMERICLITERAL() antlr.TerminalNode
	NUMERICLITERAL() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NONNUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNONNUMERICLITERAL, 0)
}

func (s *LiteralContext) NUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNUMERICLITERAL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Cobol85PreprocessorParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(687)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85PreprocessorParserNONNUMERICLITERAL || _la == Cobol85PreprocessorParserNUMERICLITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilenameContext is an interface to support dynamic dispatch.
type IFilenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILENAME() antlr.TerminalNode

	// IsFilenameContext differentiates from other interfaces.
	IsFilenameContext()
}

type FilenameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilenameContext() *FilenameContext {
	var p = new(FilenameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_filename
	return p
}

func InitEmptyFilenameContext(p *FilenameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_filename
}

func (*FilenameContext) IsFilenameContext() {}

func NewFilenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilenameContext {
	var p = new(FilenameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_filename

	return p
}

func (s *FilenameContext) GetParser() antlr.Parser { return s.parser }

func (s *FilenameContext) FILENAME() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFILENAME, 0)
}

func (s *FilenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterFilename(s)
	}
}

func (s *FilenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitFilename(s)
	}
}

func (s *FilenameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitFilename(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) Filename() (localctx IFilenameContext) {
	localctx = NewFilenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Cobol85PreprocessorParserRULE_filename)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(689)
		p.Match(Cobol85PreprocessorParserFILENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharDataKeywordContext is an interface to support dynamic dispatch.
type ICharDataKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADATA() antlr.TerminalNode
	ADV() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	ANSI() antlr.TerminalNode
	ANY() antlr.TerminalNode
	APOST() antlr.TerminalNode
	AR() antlr.TerminalNode
	ARITH() antlr.TerminalNode
	AUTO() antlr.TerminalNode
	AWO() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BLOCK0() antlr.TerminalNode
	BUF() antlr.TerminalNode
	BUFSIZE() antlr.TerminalNode
	BY() antlr.TerminalNode
	CBL() antlr.TerminalNode
	CBLCARD() antlr.TerminalNode
	CO() antlr.TerminalNode
	COBOL2() antlr.TerminalNode
	COBOL3() antlr.TerminalNode
	CODEPAGE() antlr.TerminalNode
	COMMACHAR() antlr.TerminalNode
	COMPAT() antlr.TerminalNode
	COMPILE() antlr.TerminalNode
	CP() antlr.TerminalNode
	CPP() antlr.TerminalNode
	CPSM() antlr.TerminalNode
	CS() antlr.TerminalNode
	CURR() antlr.TerminalNode
	CURRENCY() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATEPROC() antlr.TerminalNode
	DBCS() antlr.TerminalNode
	DD() antlr.TerminalNode
	DEBUG() antlr.TerminalNode
	DECK() antlr.TerminalNode
	DIAGTRUNC() antlr.TerminalNode
	DLI() antlr.TerminalNode
	DLL() antlr.TerminalNode
	DP() antlr.TerminalNode
	DTR() antlr.TerminalNode
	DU() antlr.TerminalNode
	DUMP() antlr.TerminalNode
	DYN() antlr.TerminalNode
	DYNAM() antlr.TerminalNode
	EDF() antlr.TerminalNode
	EJECT() antlr.TerminalNode
	EJPD() antlr.TerminalNode
	EN() antlr.TerminalNode
	ENGLISH() antlr.TerminalNode
	EPILOG() antlr.TerminalNode
	EXCI() antlr.TerminalNode
	EXIT() antlr.TerminalNode
	EXP() antlr.TerminalNode
	EXPORTALL() antlr.TerminalNode
	EXTEND() antlr.TerminalNode
	FASTSRT() antlr.TerminalNode
	FLAG() antlr.TerminalNode
	FLAGSTD() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FSRT() antlr.TerminalNode
	GDS() antlr.TerminalNode
	GRAPHIC() antlr.TerminalNode
	HOOK() antlr.TerminalNode
	IN() antlr.TerminalNode
	INTDATE() antlr.TerminalNode
	JA() antlr.TerminalNode
	JP() antlr.TerminalNode
	KA() antlr.TerminalNode
	LANG() antlr.TerminalNode
	LANGUAGE() antlr.TerminalNode
	LC() antlr.TerminalNode
	LENGTH() antlr.TerminalNode
	LIB() antlr.TerminalNode
	LILIAN() antlr.TerminalNode
	LIN() antlr.TerminalNode
	LINECOUNT() antlr.TerminalNode
	LINKAGE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LM() antlr.TerminalNode
	LONGMIXED() antlr.TerminalNode
	LONGUPPER() antlr.TerminalNode
	LU() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MARGINS() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MD() antlr.TerminalNode
	MDECK() antlr.TerminalNode
	MIG() antlr.TerminalNode
	MIXED() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAT() antlr.TerminalNode
	NATIONAL() antlr.TerminalNode
	NATLANG() antlr.TerminalNode
	NN() antlr.TerminalNode
	NO() antlr.TerminalNode
	NOADATA() antlr.TerminalNode
	NOADV() antlr.TerminalNode
	NOALIAS() antlr.TerminalNode
	NOAWO() antlr.TerminalNode
	NOBLOCK0() antlr.TerminalNode
	NOC() antlr.TerminalNode
	NOCBLCARD() antlr.TerminalNode
	NOCICS() antlr.TerminalNode
	NOCMPR2() antlr.TerminalNode
	NOCOMPILE() antlr.TerminalNode
	NOCPSM() antlr.TerminalNode
	NOCURR() antlr.TerminalNode
	NOCURRENCY() antlr.TerminalNode
	NOD() antlr.TerminalNode
	NODATEPROC() antlr.TerminalNode
	NODBCS() antlr.TerminalNode
	NODE() antlr.TerminalNode
	NODEBUG() antlr.TerminalNode
	NODECK() antlr.TerminalNode
	NODIAGTRUNC() antlr.TerminalNode
	NODLL() antlr.TerminalNode
	NODU() antlr.TerminalNode
	NODUMP() antlr.TerminalNode
	NODP() antlr.TerminalNode
	NODTR() antlr.TerminalNode
	NODYN() antlr.TerminalNode
	NODYNAM() antlr.TerminalNode
	NOEDF() antlr.TerminalNode
	NOEJPD() antlr.TerminalNode
	NOEPILOG() antlr.TerminalNode
	NOEXIT() antlr.TerminalNode
	NOEXP() antlr.TerminalNode
	NOEXPORTALL() antlr.TerminalNode
	NOF() antlr.TerminalNode
	NOFASTSRT() antlr.TerminalNode
	NOFEPI() antlr.TerminalNode
	NOFLAG() antlr.TerminalNode
	NOFLAGMIG() antlr.TerminalNode
	NOFLAGSTD() antlr.TerminalNode
	NOFSRT() antlr.TerminalNode
	NOGRAPHIC() antlr.TerminalNode
	NOHOOK() antlr.TerminalNode
	NOLENGTH() antlr.TerminalNode
	NOLIB() antlr.TerminalNode
	NOLINKAGE() antlr.TerminalNode
	NOLIST() antlr.TerminalNode
	NOMAP() antlr.TerminalNode
	NOMD() antlr.TerminalNode
	NOMDECK() antlr.TerminalNode
	NONAME() antlr.TerminalNode
	NONUM() antlr.TerminalNode
	NONUMBER() antlr.TerminalNode
	NOOBJ() antlr.TerminalNode
	NOOBJECT() antlr.TerminalNode
	NOOFF() antlr.TerminalNode
	NOOFFSET() antlr.TerminalNode
	NOOPSEQUENCE() antlr.TerminalNode
	NOOPT() antlr.TerminalNode
	NOOPTIMIZE() antlr.TerminalNode
	NOOPTIONS() antlr.TerminalNode
	NOP() antlr.TerminalNode
	NOPFD() antlr.TerminalNode
	NOPROLOG() antlr.TerminalNode
	NORENT() antlr.TerminalNode
	NOS() antlr.TerminalNode
	NOSEP() antlr.TerminalNode
	NOSEPARATE() antlr.TerminalNode
	NOSEQ() antlr.TerminalNode
	NOSEQUENCE() antlr.TerminalNode
	NOSOURCE() antlr.TerminalNode
	NOSPIE() antlr.TerminalNode
	NOSQL() antlr.TerminalNode
	NOSQLC() antlr.TerminalNode
	NOSQLCCSID() antlr.TerminalNode
	NOSSR() antlr.TerminalNode
	NOSSRANGE() antlr.TerminalNode
	NOSTDTRUNC() antlr.TerminalNode
	NOTERM() antlr.TerminalNode
	NOTERMINAL() antlr.TerminalNode
	NOTEST() antlr.TerminalNode
	NOTHREAD() antlr.TerminalNode
	NOTRIG() antlr.TerminalNode
	NOVBREF() antlr.TerminalNode
	NOWORD() antlr.TerminalNode
	NOX() antlr.TerminalNode
	NOXREF() antlr.TerminalNode
	NOZWB() antlr.TerminalNode
	NSEQ() antlr.TerminalNode
	NSYMBOL() antlr.TerminalNode
	NS() antlr.TerminalNode
	NUM() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	NUMPROC() antlr.TerminalNode
	OBJ() antlr.TerminalNode
	OBJECT() antlr.TerminalNode
	ON() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	OPMARGINS() antlr.TerminalNode
	OPSEQUENCE() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	OP() antlr.TerminalNode
	OPT() antlr.TerminalNode
	OPTFILE() antlr.TerminalNode
	OPTIONS() antlr.TerminalNode
	OUT() antlr.TerminalNode
	OUTDD() antlr.TerminalNode
	PFD() antlr.TerminalNode
	PGMN() antlr.TerminalNode
	PGMNAME() antlr.TerminalNode
	PPTDBG() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROLOG() antlr.TerminalNode
	QUOTE() antlr.TerminalNode
	RENT() antlr.TerminalNode
	REPLACING() antlr.TerminalNode
	RMODE() antlr.TerminalNode
	SEQ() antlr.TerminalNode
	SEQUENCE() antlr.TerminalNode
	SEP() antlr.TerminalNode
	SEPARATE() antlr.TerminalNode
	SHORT() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SP() antlr.TerminalNode
	SPACE() antlr.TerminalNode
	SPIE() antlr.TerminalNode
	SQL() antlr.TerminalNode
	SQLC() antlr.TerminalNode
	SQLCCSID() antlr.TerminalNode
	SS() antlr.TerminalNode
	SSR() antlr.TerminalNode
	SSRANGE() antlr.TerminalNode
	STD() antlr.TerminalNode
	SYSEIB() antlr.TerminalNode
	SZ() antlr.TerminalNode
	TERM() antlr.TerminalNode
	TERMINAL() antlr.TerminalNode
	TEST() antlr.TerminalNode
	THREAD() antlr.TerminalNode
	TITLE() antlr.TerminalNode
	TRIG() antlr.TerminalNode
	TRUNC() antlr.TerminalNode
	UE() antlr.TerminalNode
	UPPER() antlr.TerminalNode
	VBREF() antlr.TerminalNode
	WD() antlr.TerminalNode
	XMLPARSE() antlr.TerminalNode
	XMLSS() antlr.TerminalNode
	XOPTS() antlr.TerminalNode
	XREF() antlr.TerminalNode
	YEARWINDOW() antlr.TerminalNode
	YW() antlr.TerminalNode
	ZWB() antlr.TerminalNode
	C_CHAR() antlr.TerminalNode
	D_CHAR() antlr.TerminalNode
	E_CHAR() antlr.TerminalNode
	F_CHAR() antlr.TerminalNode
	H_CHAR() antlr.TerminalNode
	I_CHAR() antlr.TerminalNode
	M_CHAR() antlr.TerminalNode
	N_CHAR() antlr.TerminalNode
	Q_CHAR() antlr.TerminalNode
	S_CHAR() antlr.TerminalNode
	U_CHAR() antlr.TerminalNode
	W_CHAR() antlr.TerminalNode
	X_CHAR() antlr.TerminalNode

	// IsCharDataKeywordContext differentiates from other interfaces.
	IsCharDataKeywordContext()
}

type CharDataKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharDataKeywordContext() *CharDataKeywordContext {
	var p = new(CharDataKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataKeyword
	return p
}

func InitEmptyCharDataKeywordContext(p *CharDataKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataKeyword
}

func (*CharDataKeywordContext) IsCharDataKeywordContext() {}

func NewCharDataKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharDataKeywordContext {
	var p = new(CharDataKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85PreprocessorParserRULE_charDataKeyword

	return p
}

func (s *CharDataKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *CharDataKeywordContext) ADATA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserADATA, 0)
}

func (s *CharDataKeywordContext) ADV() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserADV, 0)
}

func (s *CharDataKeywordContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserALIAS, 0)
}

func (s *CharDataKeywordContext) ANSI() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserANSI, 0)
}

func (s *CharDataKeywordContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserANY, 0)
}

func (s *CharDataKeywordContext) APOST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserAPOST, 0)
}

func (s *CharDataKeywordContext) AR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserAR, 0)
}

func (s *CharDataKeywordContext) ARITH() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserARITH, 0)
}

func (s *CharDataKeywordContext) AUTO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserAUTO, 0)
}

func (s *CharDataKeywordContext) AWO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserAWO, 0)
}

func (s *CharDataKeywordContext) BIN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBIN, 0)
}

func (s *CharDataKeywordContext) BLOCK0() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBLOCK0, 0)
}

func (s *CharDataKeywordContext) BUF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBUF, 0)
}

func (s *CharDataKeywordContext) BUFSIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBUFSIZE, 0)
}

func (s *CharDataKeywordContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserBY, 0)
}

func (s *CharDataKeywordContext) CBL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCBL, 0)
}

func (s *CharDataKeywordContext) CBLCARD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCBLCARD, 0)
}

func (s *CharDataKeywordContext) CO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCO, 0)
}

func (s *CharDataKeywordContext) COBOL2() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOBOL2, 0)
}

func (s *CharDataKeywordContext) COBOL3() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOBOL3, 0)
}

func (s *CharDataKeywordContext) CODEPAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCODEPAGE, 0)
}

func (s *CharDataKeywordContext) COMMACHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOMMACHAR, 0)
}

func (s *CharDataKeywordContext) COMPAT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOMPAT, 0)
}

func (s *CharDataKeywordContext) COMPILE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCOMPILE, 0)
}

func (s *CharDataKeywordContext) CP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCP, 0)
}

func (s *CharDataKeywordContext) CPP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCPP, 0)
}

func (s *CharDataKeywordContext) CPSM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCPSM, 0)
}

func (s *CharDataKeywordContext) CS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCS, 0)
}

func (s *CharDataKeywordContext) CURR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCURR, 0)
}

func (s *CharDataKeywordContext) CURRENCY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserCURRENCY, 0)
}

func (s *CharDataKeywordContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDATA, 0)
}

func (s *CharDataKeywordContext) DATEPROC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDATEPROC, 0)
}

func (s *CharDataKeywordContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDBCS, 0)
}

func (s *CharDataKeywordContext) DD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDD, 0)
}

func (s *CharDataKeywordContext) DEBUG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDEBUG, 0)
}

func (s *CharDataKeywordContext) DECK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDECK, 0)
}

func (s *CharDataKeywordContext) DIAGTRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDIAGTRUNC, 0)
}

func (s *CharDataKeywordContext) DLI() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDLI, 0)
}

func (s *CharDataKeywordContext) DLL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDLL, 0)
}

func (s *CharDataKeywordContext) DP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDP, 0)
}

func (s *CharDataKeywordContext) DTR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDTR, 0)
}

func (s *CharDataKeywordContext) DU() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDU, 0)
}

func (s *CharDataKeywordContext) DUMP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDUMP, 0)
}

func (s *CharDataKeywordContext) DYN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDYN, 0)
}

func (s *CharDataKeywordContext) DYNAM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserDYNAM, 0)
}

func (s *CharDataKeywordContext) EDF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEDF, 0)
}

func (s *CharDataKeywordContext) EJECT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEJECT, 0)
}

func (s *CharDataKeywordContext) EJPD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEJPD, 0)
}

func (s *CharDataKeywordContext) EN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEN, 0)
}

func (s *CharDataKeywordContext) ENGLISH() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserENGLISH, 0)
}

func (s *CharDataKeywordContext) EPILOG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEPILOG, 0)
}

func (s *CharDataKeywordContext) EXCI() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXCI, 0)
}

func (s *CharDataKeywordContext) EXIT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXIT, 0)
}

func (s *CharDataKeywordContext) EXP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXP, 0)
}

func (s *CharDataKeywordContext) EXPORTALL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXPORTALL, 0)
}

func (s *CharDataKeywordContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserEXTEND, 0)
}

func (s *CharDataKeywordContext) FASTSRT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFASTSRT, 0)
}

func (s *CharDataKeywordContext) FLAG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFLAG, 0)
}

func (s *CharDataKeywordContext) FLAGSTD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFLAGSTD, 0)
}

func (s *CharDataKeywordContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFULL, 0)
}

func (s *CharDataKeywordContext) FSRT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserFSRT, 0)
}

func (s *CharDataKeywordContext) GDS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserGDS, 0)
}

func (s *CharDataKeywordContext) GRAPHIC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserGRAPHIC, 0)
}

func (s *CharDataKeywordContext) HOOK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserHOOK, 0)
}

func (s *CharDataKeywordContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserIN, 0)
}

func (s *CharDataKeywordContext) INTDATE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserINTDATE, 0)
}

func (s *CharDataKeywordContext) JA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserJA, 0)
}

func (s *CharDataKeywordContext) JP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserJP, 0)
}

func (s *CharDataKeywordContext) KA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserKA, 0)
}

func (s *CharDataKeywordContext) LANG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLANG, 0)
}

func (s *CharDataKeywordContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLANGUAGE, 0)
}

func (s *CharDataKeywordContext) LC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLC, 0)
}

func (s *CharDataKeywordContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLENGTH, 0)
}

func (s *CharDataKeywordContext) LIB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLIB, 0)
}

func (s *CharDataKeywordContext) LILIAN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLILIAN, 0)
}

func (s *CharDataKeywordContext) LIN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLIN, 0)
}

func (s *CharDataKeywordContext) LINECOUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLINECOUNT, 0)
}

func (s *CharDataKeywordContext) LINKAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLINKAGE, 0)
}

func (s *CharDataKeywordContext) LIST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLIST, 0)
}

func (s *CharDataKeywordContext) LM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLM, 0)
}

func (s *CharDataKeywordContext) LONGMIXED() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLONGMIXED, 0)
}

func (s *CharDataKeywordContext) LONGUPPER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLONGUPPER, 0)
}

func (s *CharDataKeywordContext) LU() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserLU, 0)
}

func (s *CharDataKeywordContext) MAP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMAP, 0)
}

func (s *CharDataKeywordContext) MARGINS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMARGINS, 0)
}

func (s *CharDataKeywordContext) MAX() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMAX, 0)
}

func (s *CharDataKeywordContext) MD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMD, 0)
}

func (s *CharDataKeywordContext) MDECK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMDECK, 0)
}

func (s *CharDataKeywordContext) MIG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMIG, 0)
}

func (s *CharDataKeywordContext) MIXED() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserMIXED, 0)
}

func (s *CharDataKeywordContext) NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNAME, 0)
}

func (s *CharDataKeywordContext) NAT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNAT, 0)
}

func (s *CharDataKeywordContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNATIONAL, 0)
}

func (s *CharDataKeywordContext) NATLANG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNATLANG, 0)
}

func (s *CharDataKeywordContext) NN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNN, 0)
}

func (s *CharDataKeywordContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNO, 0)
}

func (s *CharDataKeywordContext) NOADATA() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOADATA, 0)
}

func (s *CharDataKeywordContext) NOADV() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOADV, 0)
}

func (s *CharDataKeywordContext) NOALIAS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOALIAS, 0)
}

func (s *CharDataKeywordContext) NOAWO() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOAWO, 0)
}

func (s *CharDataKeywordContext) NOBLOCK0() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOBLOCK0, 0)
}

func (s *CharDataKeywordContext) NOC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOC, 0)
}

func (s *CharDataKeywordContext) NOCBLCARD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCBLCARD, 0)
}

func (s *CharDataKeywordContext) NOCICS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCICS, 0)
}

func (s *CharDataKeywordContext) NOCMPR2() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCMPR2, 0)
}

func (s *CharDataKeywordContext) NOCOMPILE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCOMPILE, 0)
}

func (s *CharDataKeywordContext) NOCPSM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCPSM, 0)
}

func (s *CharDataKeywordContext) NOCURR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCURR, 0)
}

func (s *CharDataKeywordContext) NOCURRENCY() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOCURRENCY, 0)
}

func (s *CharDataKeywordContext) NOD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOD, 0)
}

func (s *CharDataKeywordContext) NODATEPROC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODATEPROC, 0)
}

func (s *CharDataKeywordContext) NODBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODBCS, 0)
}

func (s *CharDataKeywordContext) NODE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODE, 0)
}

func (s *CharDataKeywordContext) NODEBUG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODEBUG, 0)
}

func (s *CharDataKeywordContext) NODECK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODECK, 0)
}

func (s *CharDataKeywordContext) NODIAGTRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODIAGTRUNC, 0)
}

func (s *CharDataKeywordContext) NODLL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODLL, 0)
}

func (s *CharDataKeywordContext) NODU() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODU, 0)
}

func (s *CharDataKeywordContext) NODUMP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODUMP, 0)
}

func (s *CharDataKeywordContext) NODP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODP, 0)
}

func (s *CharDataKeywordContext) NODTR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODTR, 0)
}

func (s *CharDataKeywordContext) NODYN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODYN, 0)
}

func (s *CharDataKeywordContext) NODYNAM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNODYNAM, 0)
}

func (s *CharDataKeywordContext) NOEDF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEDF, 0)
}

func (s *CharDataKeywordContext) NOEJPD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEJPD, 0)
}

func (s *CharDataKeywordContext) NOEPILOG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEPILOG, 0)
}

func (s *CharDataKeywordContext) NOEXIT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEXIT, 0)
}

func (s *CharDataKeywordContext) NOEXP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEXP, 0)
}

func (s *CharDataKeywordContext) NOEXPORTALL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOEXPORTALL, 0)
}

func (s *CharDataKeywordContext) NOF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOF, 0)
}

func (s *CharDataKeywordContext) NOFASTSRT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFASTSRT, 0)
}

func (s *CharDataKeywordContext) NOFEPI() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFEPI, 0)
}

func (s *CharDataKeywordContext) NOFLAG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFLAG, 0)
}

func (s *CharDataKeywordContext) NOFLAGMIG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFLAGMIG, 0)
}

func (s *CharDataKeywordContext) NOFLAGSTD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFLAGSTD, 0)
}

func (s *CharDataKeywordContext) NOFSRT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOFSRT, 0)
}

func (s *CharDataKeywordContext) NOGRAPHIC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOGRAPHIC, 0)
}

func (s *CharDataKeywordContext) NOHOOK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOHOOK, 0)
}

func (s *CharDataKeywordContext) NOLENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOLENGTH, 0)
}

func (s *CharDataKeywordContext) NOLIB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOLIB, 0)
}

func (s *CharDataKeywordContext) NOLINKAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOLINKAGE, 0)
}

func (s *CharDataKeywordContext) NOLIST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOLIST, 0)
}

func (s *CharDataKeywordContext) NOMAP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOMAP, 0)
}

func (s *CharDataKeywordContext) NOMD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOMD, 0)
}

func (s *CharDataKeywordContext) NOMDECK() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOMDECK, 0)
}

func (s *CharDataKeywordContext) NONAME() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNONAME, 0)
}

func (s *CharDataKeywordContext) NONUM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNONUM, 0)
}

func (s *CharDataKeywordContext) NONUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNONUMBER, 0)
}

func (s *CharDataKeywordContext) NOOBJ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOBJ, 0)
}

func (s *CharDataKeywordContext) NOOBJECT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOBJECT, 0)
}

func (s *CharDataKeywordContext) NOOFF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOFF, 0)
}

func (s *CharDataKeywordContext) NOOFFSET() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOFFSET, 0)
}

func (s *CharDataKeywordContext) NOOPSEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOPSEQUENCE, 0)
}

func (s *CharDataKeywordContext) NOOPT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOPT, 0)
}

func (s *CharDataKeywordContext) NOOPTIMIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOPTIMIZE, 0)
}

func (s *CharDataKeywordContext) NOOPTIONS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOOPTIONS, 0)
}

func (s *CharDataKeywordContext) NOP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOP, 0)
}

func (s *CharDataKeywordContext) NOPFD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOPFD, 0)
}

func (s *CharDataKeywordContext) NOPROLOG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOPROLOG, 0)
}

func (s *CharDataKeywordContext) NORENT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNORENT, 0)
}

func (s *CharDataKeywordContext) NOS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOS, 0)
}

func (s *CharDataKeywordContext) NOSEP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSEP, 0)
}

func (s *CharDataKeywordContext) NOSEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSEPARATE, 0)
}

func (s *CharDataKeywordContext) NOSEQ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSEQ, 0)
}

func (s *CharDataKeywordContext) NOSEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSEQUENCE, 0)
}

func (s *CharDataKeywordContext) NOSOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSOURCE, 0)
}

func (s *CharDataKeywordContext) NOSPIE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSPIE, 0)
}

func (s *CharDataKeywordContext) NOSQL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSQL, 0)
}

func (s *CharDataKeywordContext) NOSQLC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSQLC, 0)
}

func (s *CharDataKeywordContext) NOSQLCCSID() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSQLCCSID, 0)
}

func (s *CharDataKeywordContext) NOSSR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSSR, 0)
}

func (s *CharDataKeywordContext) NOSSRANGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSSRANGE, 0)
}

func (s *CharDataKeywordContext) NOSTDTRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOSTDTRUNC, 0)
}

func (s *CharDataKeywordContext) NOTERM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTERM, 0)
}

func (s *CharDataKeywordContext) NOTERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTERMINAL, 0)
}

func (s *CharDataKeywordContext) NOTEST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTEST, 0)
}

func (s *CharDataKeywordContext) NOTHREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTHREAD, 0)
}

func (s *CharDataKeywordContext) NOTRIG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOTRIG, 0)
}

func (s *CharDataKeywordContext) NOVBREF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOVBREF, 0)
}

func (s *CharDataKeywordContext) NOWORD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOWORD, 0)
}

func (s *CharDataKeywordContext) NOX() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOX, 0)
}

func (s *CharDataKeywordContext) NOXREF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOXREF, 0)
}

func (s *CharDataKeywordContext) NOZWB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNOZWB, 0)
}

func (s *CharDataKeywordContext) NSEQ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNSEQ, 0)
}

func (s *CharDataKeywordContext) NSYMBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNSYMBOL, 0)
}

func (s *CharDataKeywordContext) NS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNS, 0)
}

func (s *CharDataKeywordContext) NUM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNUM, 0)
}

func (s *CharDataKeywordContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNUMBER, 0)
}

func (s *CharDataKeywordContext) NUMPROC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserNUMPROC, 0)
}

func (s *CharDataKeywordContext) OBJ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOBJ, 0)
}

func (s *CharDataKeywordContext) OBJECT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOBJECT, 0)
}

func (s *CharDataKeywordContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserON, 0)
}

func (s *CharDataKeywordContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOF, 0)
}

func (s *CharDataKeywordContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOFF, 0)
}

func (s *CharDataKeywordContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOFFSET, 0)
}

func (s *CharDataKeywordContext) OPMARGINS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPMARGINS, 0)
}

func (s *CharDataKeywordContext) OPSEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPSEQUENCE, 0)
}

func (s *CharDataKeywordContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPTIMIZE, 0)
}

func (s *CharDataKeywordContext) OP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOP, 0)
}

func (s *CharDataKeywordContext) OPT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPT, 0)
}

func (s *CharDataKeywordContext) OPTFILE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPTFILE, 0)
}

func (s *CharDataKeywordContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOPTIONS, 0)
}

func (s *CharDataKeywordContext) OUT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOUT, 0)
}

func (s *CharDataKeywordContext) OUTDD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserOUTDD, 0)
}

func (s *CharDataKeywordContext) PFD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPFD, 0)
}

func (s *CharDataKeywordContext) PGMN() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPGMN, 0)
}

func (s *CharDataKeywordContext) PGMNAME() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPGMNAME, 0)
}

func (s *CharDataKeywordContext) PPTDBG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPPTDBG, 0)
}

func (s *CharDataKeywordContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPROCESS, 0)
}

func (s *CharDataKeywordContext) PROLOG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserPROLOG, 0)
}

func (s *CharDataKeywordContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserQUOTE, 0)
}

func (s *CharDataKeywordContext) RENT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserRENT, 0)
}

func (s *CharDataKeywordContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserREPLACING, 0)
}

func (s *CharDataKeywordContext) RMODE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserRMODE, 0)
}

func (s *CharDataKeywordContext) SEQ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSEQ, 0)
}

func (s *CharDataKeywordContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSEQUENCE, 0)
}

func (s *CharDataKeywordContext) SEP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSEP, 0)
}

func (s *CharDataKeywordContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSEPARATE, 0)
}

func (s *CharDataKeywordContext) SHORT() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSHORT, 0)
}

func (s *CharDataKeywordContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSIZE, 0)
}

func (s *CharDataKeywordContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSOURCE, 0)
}

func (s *CharDataKeywordContext) SP() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSP, 0)
}

func (s *CharDataKeywordContext) SPACE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSPACE, 0)
}

func (s *CharDataKeywordContext) SPIE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSPIE, 0)
}

func (s *CharDataKeywordContext) SQL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSQL, 0)
}

func (s *CharDataKeywordContext) SQLC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSQLC, 0)
}

func (s *CharDataKeywordContext) SQLCCSID() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSQLCCSID, 0)
}

func (s *CharDataKeywordContext) SS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSS, 0)
}

func (s *CharDataKeywordContext) SSR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSSR, 0)
}

func (s *CharDataKeywordContext) SSRANGE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSSRANGE, 0)
}

func (s *CharDataKeywordContext) STD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSTD, 0)
}

func (s *CharDataKeywordContext) SYSEIB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSYSEIB, 0)
}

func (s *CharDataKeywordContext) SZ() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserSZ, 0)
}

func (s *CharDataKeywordContext) TERM() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTERM, 0)
}

func (s *CharDataKeywordContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTERMINAL, 0)
}

func (s *CharDataKeywordContext) TEST() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTEST, 0)
}

func (s *CharDataKeywordContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTHREAD, 0)
}

func (s *CharDataKeywordContext) TITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTITLE, 0)
}

func (s *CharDataKeywordContext) TRIG() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTRIG, 0)
}

func (s *CharDataKeywordContext) TRUNC() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserTRUNC, 0)
}

func (s *CharDataKeywordContext) UE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserUE, 0)
}

func (s *CharDataKeywordContext) UPPER() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserUPPER, 0)
}

func (s *CharDataKeywordContext) VBREF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserVBREF, 0)
}

func (s *CharDataKeywordContext) WD() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserWD, 0)
}

func (s *CharDataKeywordContext) XMLPARSE() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXMLPARSE, 0)
}

func (s *CharDataKeywordContext) XMLSS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXMLSS, 0)
}

func (s *CharDataKeywordContext) XOPTS() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXOPTS, 0)
}

func (s *CharDataKeywordContext) XREF() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserXREF, 0)
}

func (s *CharDataKeywordContext) YEARWINDOW() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserYEARWINDOW, 0)
}

func (s *CharDataKeywordContext) YW() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserYW, 0)
}

func (s *CharDataKeywordContext) ZWB() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserZWB, 0)
}

func (s *CharDataKeywordContext) C_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserC_CHAR, 0)
}

func (s *CharDataKeywordContext) D_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserD_CHAR, 0)
}

func (s *CharDataKeywordContext) E_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserE_CHAR, 0)
}

func (s *CharDataKeywordContext) F_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserF_CHAR, 0)
}

func (s *CharDataKeywordContext) H_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserH_CHAR, 0)
}

func (s *CharDataKeywordContext) I_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserI_CHAR, 0)
}

func (s *CharDataKeywordContext) M_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserM_CHAR, 0)
}

func (s *CharDataKeywordContext) N_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserN_CHAR, 0)
}

func (s *CharDataKeywordContext) Q_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserQ_CHAR, 0)
}

func (s *CharDataKeywordContext) S_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserS_CHAR, 0)
}

func (s *CharDataKeywordContext) U_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserU_CHAR, 0)
}

func (s *CharDataKeywordContext) W_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserW_CHAR, 0)
}

func (s *CharDataKeywordContext) X_CHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85PreprocessorParserX_CHAR, 0)
}

func (s *CharDataKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharDataKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharDataKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.EnterCharDataKeyword(s)
	}
}

func (s *CharDataKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85PreprocessorListener); ok {
		listenerT.ExitCharDataKeyword(s)
	}
}

func (s *CharDataKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85PreprocessorVisitor:
		return t.VisitCharDataKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85PreprocessorParser) CharDataKeyword() (localctx ICharDataKeywordContext) {
	localctx = NewCharDataKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Cobol85PreprocessorParserRULE_charDataKeyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(691)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2346375405893844994) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-16785409) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-288230376151711745) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-19069934520762369) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&201326319) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
